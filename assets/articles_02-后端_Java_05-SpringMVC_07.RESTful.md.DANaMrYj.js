import{_ as t,a as s,o as a,aR as i}from"./chunks/framework.kUD5hkPg.js";const c=JSON.parse('{"title":"07.RESTful","description":"","frontmatter":{},"headers":[],"relativePath":"articles/02-后端/Java/05-SpringMVC/07.RESTful.md","filePath":"articles/02-后端/Java/05-SpringMVC/07.RESTful.md"}'),e={name:"articles/02-后端/Java/05-SpringMVC/07.RESTful.md"},n=i(`<h1 id="_07-restful" tabindex="-1">07.RESTful <a class="header-anchor" href="#_07-restful" aria-label="Permalink to &quot;07.RESTful&quot;">​</a></h1><h2 id="_1、restful-简介" tabindex="-1">1、RESTful 简介 <a class="header-anchor" href="#_1、restful-简介" aria-label="Permalink to &quot;1、RESTful 简介&quot;">​</a></h2><p>REST：<strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer，表现层资源状态转移。</p><h3 id="a-资源" tabindex="-1">a&gt;资源 <a class="header-anchor" href="#a-资源" aria-label="Permalink to &quot;a&gt;资源&quot;">​</a></h3><p>资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个 URI 来标识。URI 既是资源的名称，也是资源在 Web 上的地址。对某个资源感兴趣的客户端应用，可以通过资源的 URI 与其进行交互。</p><h3 id="b-资源的表述" tabindex="-1">b&gt;资源的表述 <a class="header-anchor" href="#b-资源的表述" aria-label="Permalink to &quot;b&gt;资源的表述&quot;">​</a></h3><p>资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如 HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。</p><h3 id="c-状态转移" tabindex="-1">c&gt;状态转移 <a class="header-anchor" href="#c-状态转移" aria-label="Permalink to &quot;c&gt;状态转移&quot;">​</a></h3><p>状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。</p><h2 id="_2、restful-的实现" tabindex="-1">2、RESTful 的实现 <a class="header-anchor" href="#_2、restful-的实现" aria-label="Permalink to &quot;2、RESTful 的实现&quot;">​</a></h2><p>具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。</p><p>它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。</p><p>REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。</p><table><thead><tr><th>操作</th><th>传统方式</th><th>REST 风格</th></tr></thead><tbody><tr><td>查询操作</td><td>getUserById?id=1</td><td>user/1--&gt;get 请求方式</td></tr><tr><td>保存操作</td><td>saveUser</td><td>user--&gt;post 请求方式</td></tr><tr><td>删除操作</td><td>deleteUser?id=1</td><td>user/1--&gt;delete 请求方式</td></tr><tr><td>更新操作</td><td>updateUser</td><td>user--&gt;put 请求方式</td></tr></tbody></table><h2 id="_3、hiddenhttpmethodfilter" tabindex="-1">3、HiddenHttpMethodFilter <a class="header-anchor" href="#_3、hiddenhttpmethodfilter" aria-label="Permalink to &quot;3、HiddenHttpMethodFilter&quot;">​</a></h2><p>由于浏览器只支持发送 get 和 post 方式的请求，那么该如何发送 put 和 delete 请求呢？</p><p>SpringMVC 提供了 <strong>HiddenHttpMethodFilter</strong> 帮助我们<strong>将 POST 请求转换为 DELETE 或 PUT 请求</strong></p><p><strong>HiddenHttpMethodFilter</strong> 处理 put 和 delete 请求的条件：</p><h3 id="a-当前请求的请求方式必须为-post" tabindex="-1">a&gt;当前请求的请求方式必须为 post <a class="header-anchor" href="#a-当前请求的请求方式必须为-post" aria-label="Permalink to &quot;a&gt;当前请求的请求方式必须为 post&quot;">​</a></h3><h3 id="b-当前请求必须传输请求参数method" tabindex="-1">b&gt;当前请求必须传输请求参数_method <a class="header-anchor" href="#b-当前请求必须传输请求参数method" aria-label="Permalink to &quot;b&gt;当前请求必须传输请求参数\\_method&quot;">​</a></h3><p>满足以上条件，<strong>HiddenHttpMethodFilter</strong> 过滤器就会将当前请求的请求方式转换为请求参数_method 的值，因此请求参数_method 的值才是最终的请求方式</p><p>在 web.xml 中注册<strong>HiddenHttpMethodFilter</strong></p><div class="language-xml vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">filter-name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;HiddenHttpMethodFilter&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">filter-name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">filter-class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">filter-class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">filter-mapping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">filter-name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;HiddenHttpMethodFilter&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">filter-name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">url-pattern</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;/*&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">url-pattern</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">filter-mapping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><blockquote><p>注：</p><p>目前为止，SpringMVC 中提供了两个过滤器：CharacterEncodingFilter 和 HiddenHttpMethodFilter</p><p>在 web.xml 中注册时，必须先注册 CharacterEncodingFilter，再注册 HiddenHttpMethodFilter</p><p>原因：</p><ul><li>在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字符集的</li><li>request.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作</li><li>而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作：</li><li></li></ul></blockquote><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>String paramValue = request.getParameter(this.methodParam);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div>`,25),l=[n];function r(p,h,d,o,E,k){return a(),s("div",null,l)}const u=t(e,[["render",r]]);export{c as __pageData,u as default};
