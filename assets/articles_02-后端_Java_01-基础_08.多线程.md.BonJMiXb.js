import{_ as s,a,o as i,aR as n}from"./chunks/framework.kUD5hkPg.js";const g=JSON.parse('{"title":"08.多线程","description":"","frontmatter":{},"headers":[],"relativePath":"articles/02-后端/Java/01-基础/08.多线程.md","filePath":"articles/02-后端/Java/01-基础/08.多线程.md"}'),l={name:"articles/02-后端/Java/01-基础/08.多线程.md"},e=n(`<h1 id="_08-多线程" tabindex="-1">08.多线程 <a class="header-anchor" href="#_08-多线程" aria-label="Permalink to &quot;08.多线程&quot;">​</a></h1><h2 id="一-程序、进程、线程的理解" tabindex="-1">一.程序、进程、线程的理解 <a class="header-anchor" href="#一-程序、进程、线程的理解" aria-label="Permalink to &quot;一.程序、进程、线程的理解&quot;">​</a></h2><h3 id="_1-程序-program" tabindex="-1">1.程序（program） <a class="header-anchor" href="#_1-程序-program" aria-label="Permalink to &quot;1.程序（program）&quot;">​</a></h3><p><strong>概念</strong>：是完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码。</p><h3 id="_2-进程-process" tabindex="-1">2.进程(process) <a class="header-anchor" href="#_2-进程-process" aria-label="Permalink to &quot;2.进程(process)&quot;">​</a></h3><p><strong>概念</strong>：程序的一次执行过程，或是正在运行的一个程序。</p><p><strong>说明</strong>：进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域。</p><h3 id="_3-线程-thread" tabindex="-1">3.线程(thread) <a class="header-anchor" href="#_3-线程-thread" aria-label="Permalink to &quot;3.线程(thread)&quot;">​</a></h3><p><strong>概念</strong>：进程可进一步细化为线程，是一个程序内部的的一条执行路径。</p><p><strong>说明</strong>：线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换开销小。</p><p><strong>内存结构</strong>：</p><p><img src="https://fang-kang.gitee.io/blog-img/java08.png#id=OWjot&amp;originHeight=373&amp;originWidth=525&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none" alt="" data-fancybox="gallery"></p><div class="tip custom-block"><p class="custom-block-title">提示</p><p>进程可以细化为多个线程。</p><p>每个线程，拥有自己独立的：栈、程序计数器。</p><p>多个线程，共享同一个进程中的结构：方法区、堆。</p></div><h2 id="二-并行与并发" tabindex="-1">二.并行与并发 <a class="header-anchor" href="#二-并行与并发" aria-label="Permalink to &quot;二.并行与并发&quot;">​</a></h2><h3 id="_1-单核-cpu-与多核-cpu-的理解" tabindex="-1">1.单核 CPU 与多核 CPU 的理解 <a class="header-anchor" href="#_1-单核-cpu-与多核-cpu-的理解" aria-label="Permalink to &quot;1.单核 CPU 与多核 CPU 的理解&quot;">​</a></h3><ul><li>单核<code>CPU</code>,其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过。那么<code>CPU</code>就好比收费人员。如果某个人不想交钱，那么收费人员可以把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费。）但是因为<code>CPU</code>时间单元特别短，因此感觉不出来。</li><li>如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的）</li><li>一个<code>java</code>应用程序<code>java.exe</code>,其实至少 3 个线程：<code>main</code>主线程，<code>gc</code>垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。</li></ul><h3 id="_2-并行与并发的理解" tabindex="-1">2.并行与并发的理解 <a class="header-anchor" href="#_2-并行与并发的理解" aria-label="Permalink to &quot;2.并行与并发的理解&quot;">​</a></h3><ul><li>并行：多个<code>CPU</code>同时执行多个任务。比如：多个人同时做不同的事。</li><li>并发：一个<code>CPU</code>(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事</li></ul><h2 id="三-创建多线程的两种方式" tabindex="-1">三.创建多线程的两种方式 <a class="header-anchor" href="#三-创建多线程的两种方式" aria-label="Permalink to &quot;三.创建多线程的两种方式&quot;">​</a></h2><h3 id="_1-方式一-继承于-thread-类" tabindex="-1">1.方式一：继承于 Thread 类 <a class="header-anchor" href="#_1-方式一-继承于-thread-类" aria-label="Permalink to &quot;1.方式一：继承于 Thread 类&quot;">​</a></h3><ul><li>1.创建一个继承于<code>Thread</code>类的子类</li><li>2.重写<code>Thread</code>类的<code>run()</code> <code>=&gt;</code> 将次线程声明的操作声明在<code>run()</code>中</li><li>3.创建<code>Thread</code>类的子类的对象</li><li>4.通过此对象调用<code>start()</code><ul><li>启动当前线程</li><li>调用当前线程的<code>run()</code></li></ul></li></ul><h3 id="_2-说明两个问题" tabindex="-1">2.说明两个问题 <a class="header-anchor" href="#_2-说明两个问题" aria-label="Permalink to &quot;2.说明两个问题&quot;">​</a></h3><p><strong>问题一</strong>：我们启动一个线程，必须调用<code>start()</code> ，不能调用<code>run()</code>的方式启动线程。</p><p><strong>问题二</strong>：如果再启动一个线程，就必须重新创建一个<code>Thread</code>子类的对象，调用此对象的<code>start()</code></p><h3 id="_3-方式二-实现-runnable-接口" tabindex="-1">3.方式二：实现 Runnable 接口 <a class="header-anchor" href="#_3-方式二-实现-runnable-接口" aria-label="Permalink to &quot;3.方式二：实现 Runnable 接口&quot;">​</a></h3><ul><li>1.创建一个实现了<code>Runnable</code>接口的类</li><li>2.实现类去实现<code>Runnable</code>中的抽象方法：<code>run()</code></li><li>3.创建实现类的对象</li><li>4.将此对象作为参数传递到<code>Thread</code>类的构造器中，创建<code>Thread</code>类的对象</li><li>5.通过<code>Thread</code>类的对象调用<code>start()</code></li></ul><h3 id="_4-两种方式的对比" tabindex="-1">4.两种方式的对比 <a class="header-anchor" href="#_4-两种方式的对比" aria-label="Permalink to &quot;4.两种方式的对比&quot;">​</a></h3><p><strong>开发中优先选择</strong>：实现<code>Runnable</code>接口的方式</p><p><strong>原因</strong>：</p><ul><li>实现的方式没类的单继承性的局限性</li><li>实现的方式更适合来处理多个线程共享数据的情况</li></ul><p><strong>联系</strong>：<code>public class Thread implements Runnable</code></p><p><strong>相同点</strong>：两种方式都需要重写<code>run()</code>,将线程要执行的逻辑声明在<code>run()</code>中。</p><p>目前两种方式，要想启动线程，都是调用的<code>Thread</code>类中的<code>start()</code>。</p><h2 id="四-thread-类中的常用方法" tabindex="-1">四.Thread 类中的常用方法 <a class="header-anchor" href="#四-thread-类中的常用方法" aria-label="Permalink to &quot;四.Thread 类中的常用方法&quot;">​</a></h2><h3 id="_1-常用方法" tabindex="-1">1.常用方法 <a class="header-anchor" href="#_1-常用方法" aria-label="Permalink to &quot;1.常用方法&quot;">​</a></h3><ul><li><code>start()</code>：启动当前线程，调用当前线程的<code>run()</code></li><li><code>run()</code>：通常需要重写<code>Thread</code>类中的此方法，将创建的线程要执行的操作声明在此方法中</li><li><code>currentThread()</code>：静态方法，返回执行当前代码的线程</li><li><code>getName()</code>：获取当前线程的名字</li><li><code>setName()</code>：设置当前线程的名字</li><li><code>yield()</code>：释放当前<code>cpu</code>的执行权</li><li><code>join()</code>：在线程<code>a</code>中调用线程<code>b</code>的<code>join()</code>,此时线程<code>a</code>就进入阻塞状态，直到线程<code>b</code>完全执行完以后，线程<code>a</code>才结束阻塞状态。</li><li><code>stop()</code>：已过时。当执行此方法时，强制结束当前线程</li><li><code>sleep(long millitime)</code>：让当前线程“睡眠”指定的<code>millitime</code>毫秒。在指定的<code>millitime</code>毫秒时间内。当前线程是阻塞状态</li><li><code>isAlive()</code>：判断当前线程是否存活</li></ul><h3 id="_2-线程的优先级" tabindex="-1">2.线程的优先级 <a class="header-anchor" href="#_2-线程的优先级" aria-label="Permalink to &quot;2.线程的优先级&quot;">​</a></h3><h4 id="_2-1-优先级" tabindex="-1">2.1 优先级 <a class="header-anchor" href="#_2-1-优先级" aria-label="Permalink to &quot;2.1 优先级&quot;">​</a></h4><ul><li><code>MAX_PRIORITY</code>：10</li><li><code>MIN_PRIORITY</code>：1</li><li><code>NORM_PRIORITY</code>：5 <code>=&gt;</code> 默认优先级</li></ul><h4 id="_2-2-如何获取和设置当前线程的优先级" tabindex="-1">2.2 如何获取和设置当前线程的优先级 <a class="header-anchor" href="#_2-2-如何获取和设置当前线程的优先级" aria-label="Permalink to &quot;2.2 如何获取和设置当前线程的优先级&quot;">​</a></h4><ul><li><code>getProiority()</code>：获取线程的优先级</li><li><code>setProiority(int p)</code>：设置线程的优先级</li></ul><h4 id="_2-3-说明" tabindex="-1">2.3 说明 <a class="header-anchor" href="#_2-3-说明" aria-label="Permalink to &quot;2.3 说明&quot;">​</a></h4><p>高优先级的线程要抢占低优先级线程<code>CPU</code>的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只当高优先级的线程执行完以后，低优先级的线程才执行。</p><h4 id="_2-4-补充-线程的分类" tabindex="-1">2.4 补充：线程的分类 <a class="header-anchor" href="#_2-4-补充-线程的分类" aria-label="Permalink to &quot;2.4 补充：线程的分类&quot;">​</a></h4><p>一种是守护线程，一种是用户线程。</p><h2 id="五-thread-的生命周期" tabindex="-1">五.Thread 的生命周期 <a class="header-anchor" href="#五-thread-的生命周期" aria-label="Permalink to &quot;五.Thread 的生命周期&quot;">​</a></h2><h3 id="_1-图示" tabindex="-1">1.图示 <a class="header-anchor" href="#_1-图示" aria-label="Permalink to &quot;1.图示&quot;">​</a></h3><p><img src="https://fang-kang.gitee.io/blog-img/java15.png#id=InOGW&amp;originHeight=394&amp;originWidth=786&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none" alt="" data-fancybox="gallery"></p><h3 id="_2-说明" tabindex="-1">2.说明 <a class="header-anchor" href="#_2-说明" aria-label="Permalink to &quot;2.说明&quot;">​</a></h3><p>1.生命周期关注两个概念：状态、相应的方法</p><p>2.关注：状态<code>a</code> <code>=&gt;</code> 状态<code>b</code>：哪些方法执行了（回调方法）</p><p>某个方法主动调用：状态<code>a</code> <code>=&gt;</code> 状态<code>b</code></p><p>3.阻塞：临时状态，不可以作为最终状态</p><h2 id="六-线程的同步机制" tabindex="-1">六.线程的同步机制 <a class="header-anchor" href="#六-线程的同步机制" aria-label="Permalink to &quot;六.线程的同步机制&quot;">​</a></h2><h3 id="_1-背景" tabindex="-1">1.背景 <a class="header-anchor" href="#_1-背景" aria-label="Permalink to &quot;1.背景&quot;">​</a></h3><p>例子：创建个窗口买票，总票数为 100 张，使用实现<code>Runnable</code>接口的方式</p><ul><li>1.问题：卖票过程中，出现了重票、错票 <code>=&gt;</code> 出现了线程的安全问题</li><li>2.问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。</li><li>3.如何解决：当一个线程<code>a</code>在操作<code>ticket</code>的时候，其他线程不能参与进来。直到线程<code>a</code>操作完<code>ticket</code>时，其他线程才可以开始操作<code>ticket</code>。这种情况即使线程<code>a</code>出现了阻碍，也不能被改变。</li></ul><h3 id="_2-java-解决方案-同步机制" tabindex="-1">2.Java 解决方案：同步机制 <a class="header-anchor" href="#_2-java-解决方案-同步机制" aria-label="Permalink to &quot;2.Java 解决方案：同步机制&quot;">​</a></h3><p>在<code>Java</code>中，我们通过同步机制，来解决线程的安全问题。</p><ul><li>方式一：同步代码块</li></ul><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(同步监视器){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 需要被同步的代码</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">说明：1.操作共享数据的代码，即为需要被同步的代码。 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 不能包含代码多了，也不能包含代码少了。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     2.共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     3.同步监视器：俗称：锁。任何一个类的对象，都可以充当锁。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       要求：多个线程必须要共用同一把锁。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li>方式二：同步方法</li></ul><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><strong>关于同步方法的总结</strong>：</p><p>1.同步方法仍然涉及到同步监视器，只是不需要我们显示的声明。</p><p>2.非静态的同步方式，同步监视器是：<code>this</code></p><p>静态的同步方式，同步监视器是：当前类本身</p><ul><li>方式三：Lock 锁 ---JDK5.0 新增</li></ul><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ReentrantLock lock </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReentrantLock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><strong>1.面试题：synchronized 与 Lock 的异同?</strong></p><p><strong>相同</strong>：二者都可以解决线程安全问题</p><p><strong>不同</strong>：<code>synchronized</code>机制在执行完相应的同步代码以后，自动的释放同步监视器</p><p><code>Lock</code>需要手动的启动同步 lock(),同时结束同步也需要手动的实现 unlock()</p><p><strong>2.使用的优先顺序</strong>：</p><p><code>Lock</code> <code>=&gt;</code> 同步代码块（已经进入了方法体，分配了相应资源） <code>=&gt;</code> 同步方法（在方法体之外）</p><h3 id="_3-利弊" tabindex="-1">3.利弊 <a class="header-anchor" href="#_3-利弊" aria-label="Permalink to &quot;3.利弊&quot;">​</a></h3><p>同步的方式，解决了线程的安全问题。 ---好处</p><p>操作同步代码时，只能一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。</p><h3 id="_4-面试题" tabindex="-1">4.面试题 <a class="header-anchor" href="#_4-面试题" aria-label="Permalink to &quot;4.面试题&quot;">​</a></h3><h4 id="_4-1-java-是如何解决线程安全问题的-有几种方式-并对比几种方式的不同" tabindex="-1">4.1 Java 是如何解决线程安全问题的，有几种方式？并对比几种方式的不同 <a class="header-anchor" href="#_4-1-java-是如何解决线程安全问题的-有几种方式-并对比几种方式的不同" aria-label="Permalink to &quot;4.1 Java 是如何解决线程安全问题的，有几种方式？并对比几种方式的不同&quot;">​</a></h4><h4 id="_4-2-synchronized-和-lock-方式解决线程安全问题的对比" tabindex="-1">4.2 synchronized 和 Lock 方式解决线程安全问题的对比 <a class="header-anchor" href="#_4-2-synchronized-和-lock-方式解决线程安全问题的对比" aria-label="Permalink to &quot;4.2 synchronized 和 Lock 方式解决线程安全问题的对比&quot;">​</a></h4><h3 id="_5-线程安全的单例模式-懒汉式" tabindex="-1">5.线程安全的单例模式（懒汉式） <a class="header-anchor" href="#_5-线程安全的单例模式-懒汉式" aria-label="Permalink to &quot;5.线程安全的单例模式（懒汉式）&quot;">​</a></h3><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Bank</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Bank</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Bank instance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Bank </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //方式一 效率稍差</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Bank.class){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(instance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                instance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Bank</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> instance;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //方式二 效率更高</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(instance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Bank.class){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(instance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    instance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Bank</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> instance;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h3 id="_6-死锁问题" tabindex="-1">6.死锁问题 <a class="header-anchor" href="#_6-死锁问题" aria-label="Permalink to &quot;6.死锁问题&quot;">​</a></h3><h4 id="_6-1-死锁的理解" tabindex="-1">6.1 死锁的理解 <a class="header-anchor" href="#_6-1-死锁的理解" aria-label="Permalink to &quot;6.1 死锁的理解&quot;">​</a></h4><p>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程死锁。</p><h4 id="_6-2-说明" tabindex="-1">6.2 说明 <a class="header-anchor" href="#_6-2-说明" aria-label="Permalink to &quot;6.2 说明&quot;">​</a></h4><ul><li>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续</li><li>我们使用同步时，要避免出现死锁</li></ul><h2 id="七-线程通信" tabindex="-1">七.线程通信 <a class="header-anchor" href="#七-线程通信" aria-label="Permalink to &quot;七.线程通信&quot;">​</a></h2><h3 id="_1-线程通信设计到的三个方法" tabindex="-1">1.线程通信设计到的三个方法 <a class="header-anchor" href="#_1-线程通信设计到的三个方法" aria-label="Permalink to &quot;1.线程通信设计到的三个方法&quot;">​</a></h3><ul><li>wait()：一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。</li><li>notify()：一旦执行此方法，就会唤醒被 wait 的一个线程。如果有多个线程被 wait，就唤醒优先级高的那个。</li><li>notifyAll()：一旦执行此方法，就会唤醒所以被 wait 的线程。</li></ul><h3 id="_2-说明-1" tabindex="-1">2.说明 <a class="header-anchor" href="#_2-说明-1" aria-label="Permalink to &quot;2.说明&quot;">​</a></h3><ul><li>wait()，notify()，notifyAll()方法必须使用在同步代码块或同步方法中。</li><li>wait()，notify()，notifyAll()方法的调用者必须是同步代码块或同步方法中的同步监视器。否则，会出现<code>IllegalMonitorStateException</code>异常</li><li>wait()，notify()，notifyAll()方法是定义在<code>java.lang,Object</code>类中</li></ul><h3 id="_3-面试题-sleep-和-wait-的异同" tabindex="-1">3.面试题：sleep()和 wait()的异同 <a class="header-anchor" href="#_3-面试题-sleep-和-wait-的异同" aria-label="Permalink to &quot;3.面试题：sleep()和 wait()的异同&quot;">​</a></h3><p><strong>相同点</strong>：一旦执行方法，都可以使得当前的线程进入阻塞状态。</p><p><strong>不同点</strong>：</p><ul><li>两个方法声明的位置不同：<code>Thread</code>类中声明<code>sleep()</code>,<code>Object</code>类中声明<code>wait()</code></li><li>调用的要求不同：<code>sleep()</code>可以在任何需要的场景下调用。<code>wait()</code>必须在同步代码块或同步方法中</li><li>关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，<code>sleep()</code>不会释放锁，<code>wait</code>会释放锁。</li></ul><h3 id="_4-释放锁的操作" tabindex="-1">4.释放锁的操作 <a class="header-anchor" href="#_4-释放锁的操作" aria-label="Permalink to &quot;4.释放锁的操作&quot;">​</a></h3><p><img src="https://fang-kang.gitee.io/blog-img/java16.png#id=oDlTe&amp;originHeight=323&amp;originWidth=773&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none" alt="" data-fancybox="gallery"></p><h3 id="_5-不会释放锁的操作" tabindex="-1">5.不会释放锁的操作 <a class="header-anchor" href="#_5-不会释放锁的操作" aria-label="Permalink to &quot;5.不会释放锁的操作&quot;">​</a></h3><p><img src="https://fang-kang.gitee.io/blog-img/java17.png#id=V3nOr&amp;originHeight=281&amp;originWidth=737&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none" alt="" data-fancybox="gallery"></p><h2 id="八-jdk5-0-新增线程创建的方式" tabindex="-1">八.JDK5.0 新增线程创建的方式 <a class="header-anchor" href="#八-jdk5-0-新增线程创建的方式" aria-label="Permalink to &quot;八.JDK5.0 新增线程创建的方式&quot;">​</a></h2><h3 id="_1-新增方式一-实现-callable-接口-jdk5-0-新增" tabindex="-1">1.新增方式一：实现 Callable 接口 ---JDK5.0 新增 <a class="header-anchor" href="#_1-新增方式一-实现-callable-接口-jdk5-0-新增" aria-label="Permalink to &quot;1.新增方式一：实现 Callable 接口 ---JDK5.0 新增&quot;">​</a></h3><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1.创建一个实现Callable接口的实现类</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NumThread</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Callable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 2.实现call(),将此线程需要执行的操作声明在call()中</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">throws</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Exception {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ThreadNew</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 3.创建Callable接口实现类的对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        NumThread numThread </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NumThread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        FutureTask futureTask </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FutureTask</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(numThread);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Thread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(futureTask).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            //6.获取Callable中call方法返回值</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            //get()返回值即为futureTask构造器参数Callable实现类重写的call()的返回值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            Object sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> futureTask.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;总和为：&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (InterruptedException </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            e.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printStackTrace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (ExecutionException </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            e.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printStackTrace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><p><strong>说明：如何理解实现</strong><code>**Callable**</code><strong>接口的方式创建多线程比实现</strong><code>**Runnable**</code><strong>接口创建多线程方式强大？</strong></p><ul><li><code>call()</code>可以有返回值</li><li><code>call()</code>可以抛出异常，被外面的操作捕获，获取异常的信息</li><li><code>Callable</code>支持泛型</li></ul><h3 id="_2-新增方式二-使用线程池" tabindex="-1">2.新增方式二：使用线程池 <a class="header-anchor" href="#_2-新增方式二-使用线程池" aria-label="Permalink to &quot;2.新增方式二：使用线程池&quot;">​</a></h3><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NumThread2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Runnable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentThread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NumThread3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Runnable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentThread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ThreadPool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //1.提供指定数量的线程池</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ExecutorService service </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Executors.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newFixedThreadPool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ThreadPoolExecutor service1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (ThreadPoolExecutor)service;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //设置线程池属性</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//        System.out.println(service.getClass());</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//        service1.setCorePoolSize(15);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//        service1.setKeepAliveTime();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //2.执行指定线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        service.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NumThread2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//适合适用于Runnable</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        service.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NumThread3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//适合适用于Runnable</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//        service.submit();//适合适用于Callable</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        service.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">shutdown</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//关闭连接池</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><p><strong>好处</strong>：</p><ul><li>1.提高响应速度（减少了创建新线程的时间）</li><li>2.降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li><li>3.便于线程管理</li><li>corePoolSize：核心池大小</li><li>maximumPoolSize：最大线程数</li><li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li></ul><h3 id="_3-面试题-java-中多线程的创建有几种方式" tabindex="-1">3.面试题：Java 中多线程的创建有几种方式？ <a class="header-anchor" href="#_3-面试题-java-中多线程的创建有几种方式" aria-label="Permalink to &quot;3.面试题：Java 中多线程的创建有几种方式？&quot;">​</a></h3><p>四种</p>`,112),p=[e];function h(t,k,r,d,c,o){return i(),a("div",null,p)}const b=s(l,[["render",h]]);export{g as __pageData,b as default};
