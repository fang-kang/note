import{_ as a,a as s,o as i,aR as e}from"./chunks/framework.kUD5hkPg.js";const b=JSON.parse('{"title":"05.面向对象-中","description":"","frontmatter":{},"headers":[],"relativePath":"articles/02-后端/Java/01-基础/05.面向对象-中.md","filePath":"articles/02-后端/Java/01-基础/05.面向对象-中.md"}'),n={name:"articles/02-后端/Java/01-基础/05.面向对象-中.md"},l=e(`<h1 id="_05-面向对象-中" tabindex="-1">05.面向对象-中 <a class="header-anchor" href="#_05-面向对象-中" aria-label="Permalink to &quot;05.面向对象-中&quot;">​</a></h1><h2 id="一-面向对象的特征二-继承性" tabindex="-1">一.面向对象的特征二：继承性 <a class="header-anchor" href="#一-面向对象的特征二-继承性" aria-label="Permalink to &quot;一.面向对象的特征二：继承性&quot;">​</a></h2><h3 id="_1-为什么要有类的继承性-继承性的好处" tabindex="-1">1.为什么要有类的继承性？（继承性的好处） <a class="header-anchor" href="#_1-为什么要有类的继承性-继承性的好处" aria-label="Permalink to &quot;1.为什么要有类的继承性？（继承性的好处）&quot;">​</a></h3><ul><li>减少了代码的冗余，提高了代码的复用性</li><li>便于功能的扩展</li><li>为之后多态性的使用，提供了前提</li></ul><h3 id="_2-继承性的格式" tabindex="-1">2.继承性的格式 <a class="header-anchor" href="#_2-继承性的格式" aria-label="Permalink to &quot;2.继承性的格式&quot;">​</a></h3><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // A:子类、派生类、subclass</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // B:父类、超类、基类、superclass</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_3-子类继承父类以后有哪些不同" tabindex="-1">3.子类继承父类以后有哪些不同？ <a class="header-anchor" href="#_3-子类继承父类以后有哪些不同" aria-label="Permalink to &quot;3.子类继承父类以后有哪些不同？&quot;">​</a></h3><p>体现：</p><p>一旦子类<code>A</code>继承父类<code>B</code>以后，子类<code>A</code>就获取了父类<code>B</code>中声明的所有的属性和方法。</p><p>特别的,父类中声明为<code>private</code>的属性或方法，子类继承父类以后，仍然认为获取了父类中私有结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已。</p><p>子类继承父类以后，还可以声明自己特有的属性和方法：实现功能的拓展。</p><ul><li>子类和父类的关系，不同于子集和集合的关系。</li><li><code>extends</code>:延展、扩展</li></ul><h3 id="_4-java-中继承性的说明" tabindex="-1">4.Java 中继承性的说明 <a class="header-anchor" href="#_4-java-中继承性的说明" aria-label="Permalink to &quot;4.Java 中继承性的说明&quot;">​</a></h3><ul><li>一个类可以被多个子类继承。</li><li><code>Java</code>中类的单继承性：一个类只能有一个父类</li><li>子父类是相对的概念</li><li>子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类</li><li>子类继承的父类以后，就获取了直接父类以及所间接父类中声明的属性和方法</li></ul><p>图示：</p><p><img src="https://fang-kang.gitee.io/blog-img/java10.png#id=uQcPE&amp;originHeight=331&amp;originWidth=652&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none" alt="" data-fancybox="gallery"></p><h3 id="_5-java-lang-object-类的理解" tabindex="-1">5.java.lang.Object 类的理解 <a class="header-anchor" href="#_5-java-lang-object-类的理解" aria-label="Permalink to &quot;5.java.lang.Object 类的理解&quot;">​</a></h3><ul><li>如果我们没显示的声明一个类的父类的话，则此类继承与<code>java.lang.Object</code>类</li><li>所有的<code>java</code>类(除<code>java.lang.Object</code>类之外都直接或间接的继承于<code>java.lang.Object</code>类)</li><li>意味着，所有的<code>java</code>类具有<code>java.lang.Object</code>类声明的功能</li></ul><h2 id="二-方法的重写" tabindex="-1">二.方法的重写 <a class="header-anchor" href="#二-方法的重写" aria-label="Permalink to &quot;二.方法的重写&quot;">​</a></h2><h3 id="_1-什么是方法的重写-override-或-overwrite" tabindex="-1">1.什么是方法的重写（override 或 overwrite）？ <a class="header-anchor" href="#_1-什么是方法的重写-override-或-overwrite" aria-label="Permalink to &quot;1.什么是方法的重写（override 或 overwrite）？&quot;">​</a></h3><p>子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作。</p><h3 id="_2-应用" tabindex="-1">2.应用 <a class="header-anchor" href="#_2-应用" aria-label="Permalink to &quot;2.应用&quot;">​</a></h3><p>重写以后，当创建子类对象以后，通过子类对象调用字父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。</p><h3 id="_3-举例" tabindex="-1">3.举例 <a class="header-anchor" href="#_3-举例" aria-label="Permalink to &quot;3.举例&quot;">​</a></h3><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Circle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> double</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> findArea</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 求面积</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Cylinder</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Circle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> double</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> findArea</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 求表面积</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="_4-重写的规则" tabindex="-1">4.重写的规则 <a class="header-anchor" href="#_4-重写的规则" aria-label="Permalink to &quot;4.重写的规则&quot;">​</a></h3><p><strong>方法的声明</strong>：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">权限修饰符 返回值类型 方法名（形参列表） thows 异常的类型{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    方法体</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>约定俗称</strong>：子类中的叫重写的方法，父类中的叫被重写的方法。</p><ul><li>子类重写的方法的方法名和形参列表与父类的被重写的方法的方法名和形参列表相同</li><li>子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符 <strong>特殊情况</strong>：子类不能重写父类中声明为<code>private</code>权限的方法</li><li>返回值类型 <ul><li>父类被重写的方法的返回值类型是<code>void</code>,则子类重写的方法的返回值类型只能是<code>void</code></li><li>父类被重写的方法的返回值类型是<code>A类型</code>,则子类重写的方法的返回值类型可能是<code>A类</code>或<code>A类的子类</code></li><li>父类被重写的方法的返回值类型是<code>基本数据类型（比如:double）</code>,则子类重写的方法的返回值类型必须是是相同的基本数据类型(必须也是<code>double</code>)</li></ul></li><li>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</li></ul><p>子类和父类中的同名同参数的方法要么都声明为非<code>static</code>的（考虑重写，要么都声明为<code>static</code>的（不是重写））</p><h3 id="_5-面试题-区分方法的重载和重写" tabindex="-1">5.面试题:区分方法的重载和重写 <a class="header-anchor" href="#_5-面试题-区分方法的重载和重写" aria-label="Permalink to &quot;5.面试题:区分方法的重载和重写&quot;">​</a></h3><ul><li>二者的概念</li><li>重载和重写的具体规则</li><li>重载：不表现为多态性 重写：表现为多态性</li><li>重载，是指允许存在多个同名方法，而这些方法的参数不同，编辑器根据方法不同的参数列表，对同名方法的名称做修饰。对于编辑器而言，这些同名方法构成了不同的方法。它们的调用地址在编译期就绑定了。<code>Java</code>的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。 所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”; 而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”; 引用一句<code>Bruce Eckel</code>的话：“不要犯傻，如果它不是晚绑定，它就不是多态。&quot;;</li></ul><h2 id="三-关键字-super" tabindex="-1">三.关键字：super <a class="header-anchor" href="#三-关键字-super" aria-label="Permalink to &quot;三.关键字：super&quot;">​</a></h2><h3 id="_1-理解" tabindex="-1">1.理解 <a class="header-anchor" href="#_1-理解" aria-label="Permalink to &quot;1.理解&quot;">​</a></h3><p><code>super</code>关键字可以理解为父类的</p><h3 id="_2-可以用来调用的结构" tabindex="-1">2.可以用来调用的结构 <a class="header-anchor" href="#_2-可以用来调用的结构" aria-label="Permalink to &quot;2.可以用来调用的结构&quot;">​</a></h3><p>属性、方法、构造器</p><h3 id="_3-super-调用属性、方法" tabindex="-1">3.super 调用属性、方法 <a class="header-anchor" href="#_3-super-调用属性、方法" aria-label="Permalink to &quot;3.super 调用属性、方法&quot;">​</a></h3><ul><li>我们可以在子类的方法或构造器中。通过使用<code>super</code>.属性或<code>super</code>.方法的方式，显示的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略<code>super</code></li><li>特殊情况：当子类和父类中定义了同名的属性时，我们想要在子类中调用父类中声明的属性，则必须显示的使用<code>super</code>.属性的方式，表明调用的是父类中声明的属性</li><li>特殊情况：当子类重写了父类中的方法以后，我们想要在子类的方法中调用父类中被重写的方法时，则必须显示的使用<code>super</code>.方法的方式，表明调用的是父类中被重写的方法</li></ul><h3 id="_4-super-调用构造器" tabindex="-1">4.super 调用构造器 <a class="header-anchor" href="#_4-super-调用构造器" aria-label="Permalink to &quot;4.super 调用构造器&quot;">​</a></h3><ul><li>我们可以在子类的构造器中显示的使用<code>super(形参列表)</code>的方式，调用父类中声明的指定的构造器</li><li><code>super(形参列表)</code>的使用，必须声明在子类构造器的首行</li><li>我们在类的构造器中，针对于<code>this(形参列表)</code>和<code>super(形参列表)</code>只能二选一，不能同时出现</li><li>在构造器的首行，没显示的声明<code>this(形参列表)</code>或<code>super(形参列表)</code>，则默认调用的是父类中空参的构造器：<code>super()</code></li><li>在类的多个构造器中，至少一个类的构造器中使用了<code>super(形参列表)</code>，调用父类中的构造器</li></ul><h2 id="四-子类对象实例化全过程" tabindex="-1">四.子类对象实例化全过程 <a class="header-anchor" href="#四-子类对象实例化全过程" aria-label="Permalink to &quot;四.子类对象实例化全过程&quot;">​</a></h2><p>理解即可。</p><h3 id="_1-从结果上看-继承性" tabindex="-1">1.从结果上看：继承性 <a class="header-anchor" href="#_1-从结果上看-继承性" aria-label="Permalink to &quot;1.从结果上看：继承性&quot;">​</a></h3><ul><li>子类继承父类以后，就获取了父类中声明的属性或方法。</li><li>创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。</li></ul><h3 id="_2-从过程上看" tabindex="-1">2.从过程上看 <a class="header-anchor" href="#_2-从过程上看" aria-label="Permalink to &quot;2.从过程上看&quot;">​</a></h3><p>当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类构造器，...直到调用了<code>java.lang.Object</code>类中空参的构造器为止。 正因为加载过所有的父类的结构，所以才可以看到内存中父类的结构，子类对象才可以考虑进行调用。</p><h3 id="_3-强调说明" tabindex="-1">3.强调说明 <a class="header-anchor" href="#_3-强调说明" aria-label="Permalink to &quot;3.强调说明&quot;">​</a></h3><p>虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为<code>new</code>的子类对象。</p><h2 id="五-面向对象的特征三-多态性" tabindex="-1">五.面向对象的特征三：多态性 <a class="header-anchor" href="#五-面向对象的特征三-多态性" aria-label="Permalink to &quot;五.面向对象的特征三：多态性&quot;">​</a></h2><h3 id="_1-多态性的理解" tabindex="-1">1.多态性的理解 <a class="header-anchor" href="#_1-多态性的理解" aria-label="Permalink to &quot;1.多态性的理解&quot;">​</a></h3><p>可以理解为一个事物的多种形态。</p><h3 id="_2-何为多态性" tabindex="-1">2.何为多态性 <a class="header-anchor" href="#_2-何为多态性" aria-label="Permalink to &quot;2.何为多态性&quot;">​</a></h3><p><strong>对象的多态性</strong>：父类的引用指向子类的对象（或子类的对象赋给父类的引用）</p><p><strong>举例</strong>：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Person p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Man</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Object obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Date</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_3-多态性的使用-虚拟方法调用" tabindex="-1">3.多态性的使用:虚拟方法调用 <a class="header-anchor" href="#_3-多态性的使用-虚拟方法调用" aria-label="Permalink to &quot;3.多态性的使用:虚拟方法调用&quot;">​</a></h3><ul><li>有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。</li><li>总结：编译，看左边；运行，看右边。</li></ul><h3 id="_4-多态性的使用前提" tabindex="-1">4.多态性的使用前提 <a class="header-anchor" href="#_4-多态性的使用前提" aria-label="Permalink to &quot;4.多态性的使用前提&quot;">​</a></h3><ul><li>类的继承关系</li><li>方法的重写</li></ul><h3 id="_5-多态性的应用举例" tabindex="-1">5.多态性的应用举例 <a class="header-anchor" href="#_5-多态性的应用举例" aria-label="Permalink to &quot;5.多态性的应用举例&quot;">​</a></h3><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 举例一：</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Animal animal){</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//Animal animal = new Dog();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    animal.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">eat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    animal.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">shout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 举例二：</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> method</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Object obj){</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_6-多态性使用的注意点" tabindex="-1">6.多态性使用的注意点 <a class="header-anchor" href="#_6-多态性使用的注意点" aria-label="Permalink to &quot;6.多态性使用的注意点&quot;">​</a></h3><p>对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）</p><h3 id="_7-关于向上转型和向下转型" tabindex="-1">7.关于向上转型和向下转型 <a class="header-anchor" href="#_7-关于向上转型和向下转型" aria-label="Permalink to &quot;7.关于向上转型和向下转型&quot;">​</a></h3><h4 id="_7-1-向上转型-多态" tabindex="-1">7.1 向上转型:多态 <a class="header-anchor" href="#_7-1-向上转型-多态" aria-label="Permalink to &quot;7.1 向上转型:多态&quot;">​</a></h4><h4 id="_7-2-向下转型" tabindex="-1">7.2 向下转型 <a class="header-anchor" href="#_7-2-向下转型" aria-label="Permalink to &quot;7.2 向下转型&quot;">​</a></h4><h5 id="_7-2-1-为什么使用向下转型" tabindex="-1">7.2.1 为什么使用向下转型 <a class="header-anchor" href="#_7-2-1-为什么使用向下转型" aria-label="Permalink to &quot;7.2.1 为什么使用向下转型&quot;">​</a></h5><p>有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。</p><h5 id="_7-2-2-如何实现向下转型" tabindex="-1">7.2.2 如何实现向下转型 <a class="header-anchor" href="#_7-2-2-如何实现向下转型" aria-label="Permalink to &quot;7.2.2 如何实现向下转型&quot;">​</a></h5><p>使用强制类型转换符:<code>()</code></p><h5 id="_7-2-3-使用时的注意点" tabindex="-1">7.2.3 使用时的注意点 <a class="header-anchor" href="#_7-2-3-使用时的注意点" aria-label="Permalink to &quot;7.2.3 使用时的注意点&quot;">​</a></h5><ul><li>使用强转时，可能出现<code>ClassCastException</code>的异常。</li><li>为了避免在向下转型时出现<code>ClassCastException</code>的异常，我们在向下转型之前，先进行<code>instanceof</code>的判断，一旦返回<code>true</code>，就进行向下转型。如果返回<code>false</code>，不进行向下转型。</li></ul><h5 id="_7-2-4-instanceof-的使用" tabindex="-1">7.2.4 instanceof 的使用 <a class="header-anchor" href="#_7-2-4-instanceof-的使用" aria-label="Permalink to &quot;7.2.4 instanceof 的使用&quot;">​</a></h5><ul><li><code>a instanceof A</code>：判断对象<code>a</code>是否是类<code>A</code>的实例。如果是，返回<code>true</code>;如果不是，返回<code>false</code>。</li><li>如果<code>a instanceof A</code>返回<code>true</code>,则<code>a instanceof B</code>也返回<code>true</code>。其中，类<code>B</code>是类<code>A</code>的父类。</li><li>要求<code>a</code>所属的类与类<code>A</code>必须是子类和父类的关系，否则编译错误。</li></ul><h5 id="_7-2-5-图示" tabindex="-1">7.2.5 图示 <a class="header-anchor" href="#_7-2-5-图示" aria-label="Permalink to &quot;7.2.5 图示&quot;">​</a></h5><p><img src="https://fang-kang.gitee.io/blog-img/java11.png#id=MTKHa&amp;originHeight=329&amp;originWidth=600&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none" alt="" data-fancybox="gallery"></p><h3 id="_8-面试题" tabindex="-1">8.面试题 <a class="header-anchor" href="#_8-面试题" aria-label="Permalink to &quot;8.面试题&quot;">​</a></h3><h4 id="_8-1-谈谈你对多态性的理解" tabindex="-1">8.1 谈谈你对多态性的理解？ <a class="header-anchor" href="#_8-1-谈谈你对多态性的理解" aria-label="Permalink to &quot;8.1 谈谈你对多态性的理解？&quot;">​</a></h4><ul><li>实现代码的通用性。</li><li><code>Object</code>类中定义的<code>public boolean eauals(Object obj){}</code></li><li>抽象类和接口的使用肯定体现了多态性。（抽象类、接口不能实例化）</li></ul><h4 id="_8-2-多态是编译时行为还是运行时行为" tabindex="-1">8.2 多态是编译时行为还是运行时行为？ <a class="header-anchor" href="#_8-2-多态是编译时行为还是运行时行为" aria-label="Permalink to &quot;8.2 多态是编译时行为还是运行时行为？&quot;">​</a></h4><p>运行时行为</p><h2 id="六-object-类的使用" tabindex="-1">六.Object 类的使用 <a class="header-anchor" href="#六-object-类的使用" aria-label="Permalink to &quot;六.Object 类的使用&quot;">​</a></h2><h3 id="_1-java-lang-object-类的说明" tabindex="-1">1.java.lang.Object 类的说明 <a class="header-anchor" href="#_1-java-lang-object-类的说明" aria-label="Permalink to &quot;1.java.lang.Object 类的说明&quot;">​</a></h3><ul><li><code>Object</code>类是所有<code>Java</code>类的根父类</li><li>如果在类的声明中未使用<code>extends</code>关键字指明其父类，则默认父类为<code>java.lang.Object</code>类</li><li><code>Object</code>类中的功能（属性、方法）具有通用性。 <ul><li>属性：无</li><li>方法：<code>equals()</code> / <code>toString()</code> / <code>getClass()</code> / <code>hashCode()</code> / <code>clone()</code> / <code>finalize()</code> / <code>wait()</code> / <code>notify()</code> / <code>notifyAll()</code></li></ul></li><li><code>Object</code>类只声明了一个空参构造器</li></ul><h3 id="_2-equals-方法" tabindex="-1">2.equals()方法 <a class="header-anchor" href="#_2-equals-方法" aria-label="Permalink to &quot;2.equals()方法&quot;">​</a></h3><h4 id="_2-1-equals-的使用" tabindex="-1">2.1 equals()的使用 <a class="header-anchor" href="#_2-1-equals-的使用" aria-label="Permalink to &quot;2.1 equals()的使用&quot;">​</a></h4><ul><li>是一个方法，而非运算符</li><li>只能适用于引用数据类型</li><li><code>Object</code>类中<code>equals()</code>的定义: <strong>说明</strong>：<code>Object</code>类中定义的<code>equals()</code>和<code>==</code>的作用是相同的：比较两个对象的地址是否相同，即两个引用是否指向同一个对象实体</li></ul><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> boolean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> equals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Object obj){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>像<code>String</code>、<code>Date</code>、<code>File</code>、包装类等都重写了<code>Object</code>类中<code>equals()</code>方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象“实体内容”是否相同。</li><li>通常情况下，我们自定义的类如果使用<code>equals()</code>的话，也通常是比较两个对象“实体内容”是否相同。那么，我们就需要对<code>Object</code>类中定义的<code>equals()</code>进行重写。 <strong>重写的原则</strong>：比较两个对象“实体内容”是否相同。</li></ul><h4 id="_2-2-如何重写-equals" tabindex="-1">2.2 如何重写 equals() <a class="header-anchor" href="#_2-2-如何重写-equals" aria-label="Permalink to &quot;2.2 如何重写 equals()&quot;">​</a></h4><h5 id="_2-2-1-手动重写举例" tabindex="-1">2.2.1 手动重写举例 <a class="header-anchor" href="#_2-2-1-手动重写举例" aria-label="Permalink to &quot;2.2.1 手动重写举例&quot;">​</a></h5><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    String name;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 重写equals()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> boolean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> equals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Object </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">obj</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">instanceof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> User){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            User u </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (User)obj;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> u.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">equals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(u.name);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h5 id="_2-2-2-开发中如何实现-自动生成" tabindex="-1">2.2.2 开发中如何实现:自动生成 <a class="header-anchor" href="#_2-2-2-开发中如何实现-自动生成" aria-label="Permalink to &quot;2.2.2 开发中如何实现:自动生成&quot;">​</a></h5><h4 id="_2-3-回顾-运算符的使用" tabindex="-1">2.3 回顾 == 运算符的使用 <a class="header-anchor" href="#_2-3-回顾-运算符的使用" aria-label="Permalink to &quot;2.3 回顾 == 运算符的使用&quot;">​</a></h4><p><code>==</code>：运算符</p><ul><li>可以使用在<strong>基本数据类型变量</strong>和<strong>引用数据类型变量</strong>中</li><li>如果比较的是<strong>基本数据类型变量</strong>：比较两个变量保存的<strong>数据是否相等</strong>。（不一定类型相同） 如果比较的是<strong>引用数据类型变量</strong>：比较两个对象的<strong>地址值是否相同</strong>，即两个引用是否指向同一个对象实体</li></ul><p><strong>补充</strong>：<code>==</code>符号使用时，必须保证符号左右两边的变量类型一致。</p><h3 id="_3-tostring-方法" tabindex="-1">3.toString()方法 <a class="header-anchor" href="#_3-tostring-方法" aria-label="Permalink to &quot;3.toString()方法&quot;">​</a></h3><h4 id="_3-1-tostring-的使用" tabindex="-1">3.1 toString()的使用 <a class="header-anchor" href="#_3-1-tostring-的使用" aria-label="Permalink to &quot;3.1 toString()的使用&quot;">​</a></h4><ul><li>当我们输出一个对象的引用时，实际上就是调用当前对象的<code>toString()</code></li><li><code>Object</code>类中<code>toString()</code>的定义：</li></ul><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;@&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Integer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toHexString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hashCode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>像<code>String</code>、<code>Date</code>、<code>File</code>、包装类等都重写了<code>Object</code>类中<code>toString()</code>方法。 使得在调用对象的<code>toString()</code>时，返回“实体内容”信息。</li><li>自定义类也可以重写<code>toString()</code>方法，当调用此方法时，返回对象的“实体内容”。</li></ul><h4 id="_3-2-如何重写-tostring" tabindex="-1">3.2 如何重写 toString() <a class="header-anchor" href="#_3-2-如何重写-tostring" aria-label="Permalink to &quot;3.2 如何重写 toString()&quot;">​</a></h4><p>举例：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 自动实现</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Customer [name=&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;, age=&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;]&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_4-面试题" tabindex="-1">4.面试题 <a class="header-anchor" href="#_4-面试题" aria-label="Permalink to &quot;4.面试题&quot;">​</a></h3><h4 id="_4-1-final、finally、finalize-的区别" tabindex="-1">4.1 final、finally、finalize 的区别 <a class="header-anchor" href="#_4-1-final、finally、finalize-的区别" aria-label="Permalink to &quot;4.1 final、finally、finalize 的区别&quot;">​</a></h4><h4 id="_4-2-和-equals-的区别" tabindex="-1">4.2 == 和 equals()的区别 <a class="header-anchor" href="#_4-2-和-equals-的区别" aria-label="Permalink to &quot;4.2 == 和 equals()的区别&quot;">​</a></h4><h2 id="七-单元测试方法" tabindex="-1">七.单元测试方法 <a class="header-anchor" href="#七-单元测试方法" aria-label="Permalink to &quot;七.单元测试方法&quot;">​</a></h2><h3 id="_1-java-中的-junit-单元测试" tabindex="-1">1.Java 中的 Junit 单元测试 <a class="header-anchor" href="#_1-java-中的-junit-单元测试" aria-label="Permalink to &quot;1.Java 中的 Junit 单元测试&quot;">​</a></h3><p><strong>步骤</strong>：</p><ol><li>选中当前工程，右键 build path - add libraries - JUnit4 - 下一步</li><li>创建<code>Java</code>类，进行单元测试 此时的<code>Java</code>类要求：</li></ol><ul><li>此类是<code>public</code>的</li><li>此类提供公共的无参构造器</li></ul><ol start="3"><li>此类中声明单元测试方法 此时的单元测试方法：方法的权限是<code>public</code>,没返回值，没形参</li><li>此单元测试方法上需要声明注解：<code>@Test</code>,并在单元测试类中导入：<code>import org.junit.Test;</code></li><li>声明好单元测试方法以后，就可以在方法体内测试相关的代码。</li><li>写完代码以后，左键双击单元测试方法名，右键：<code>run as</code>- <code>JUnit Test</code></li></ol><p><strong>说明</strong>：</p><ul><li>如果执行结果没任何异常：绿条</li><li>如果执行结果出现异常：红条</li></ul><h2 id="八-包装类的使用" tabindex="-1">八.包装类的使用 <a class="header-anchor" href="#八-包装类的使用" aria-label="Permalink to &quot;八.包装类的使用&quot;">​</a></h2><h3 id="_1-为什么要有包装类-或封装类" tabindex="-1">1.为什么要有包装类（或封装类） <a class="header-anchor" href="#_1-为什么要有包装类-或封装类" aria-label="Permalink to &quot;1.为什么要有包装类（或封装类）&quot;">​</a></h3><p>为了使基本数据类型的变量具有类的特征，引入包装类。</p><h3 id="_2-基本数据类型与对应的包装类" tabindex="-1">2.基本数据类型与对应的包装类 <a class="header-anchor" href="#_2-基本数据类型与对应的包装类" aria-label="Permalink to &quot;2.基本数据类型与对应的包装类&quot;">​</a></h3><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td><strong>char</strong></td><td><strong>Character</strong></td></tr><tr><td>double</td><td>Double</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td><strong>int</strong></td><td><strong>Integer</strong></td></tr><tr><td>long</td><td>Long</td></tr></tbody></table><h3 id="_3-需要掌握的类型间的转换" tabindex="-1">3.需要掌握的类型间的转换 <a class="header-anchor" href="#_3-需要掌握的类型间的转换" aria-label="Permalink to &quot;3.需要掌握的类型间的转换&quot;">​</a></h3><p><img src="https://fang-kang.gitee.io/blog-img/java12.png#id=bzyri&amp;originHeight=473&amp;originWidth=861&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none" alt="" data-fancybox="gallery"></p><p><strong>简易版</strong>：</p><ul><li>基本数据类型 <code>&lt;=&gt;</code> 包装类：<code>JDK5.0</code>新特性：自动装箱与自动拆箱</li><li>基本数据类型 、包装类 <code>&lt;=&gt;</code> <code>String</code>：调用<code>String</code>重载的<code>valueOf(Xxx xxx)</code></li><li><code>String</code> <code>&lt;=&gt;</code> 基本数据类型 、包装类：调用包装类的的<code>parseXxx(String s)</code></li></ul><p><strong>注意</strong>：转换时，可能会报<code>NumberFormatException</code></p><p><strong>应用场景举例</strong>：</p><p><code>Vector</code>类中关于添加元素，只定义了形参为<code>Object</code>类型的方法：</p><p><code>v.addElement(Object obj);</code> // 基本数据类型 <code>=&gt;</code> 包装类 <code>=&gt;</code> 使用多态</p>`,132),t=[l];function h(r,d,p,o,c,k){return i(),s("div",null,t)}const g=a(n,[["render",h]]);export{b as __pageData,g as default};
