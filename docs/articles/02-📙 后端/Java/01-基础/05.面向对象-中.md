# 05.面向对象-中

## 一.面向对象的特征二：继承性

### 1.为什么要有类的继承性？（继承性的好处）

- 减少了代码的冗余，提高了代码的复用性
- 便于功能的扩展
- 为之后多态性的使用，提供了前提

### 2.继承性的格式

```java
class A extends B{
   // A:子类、派生类、subclass
   // B:父类、超类、基类、superclass
}
```

### 3.子类继承父类以后有哪些不同？

体现：

一旦子类`A`继承父类`B`以后，子类`A`就获取了父类`B`中声明的所有的属性和方法。

特别的,父类中声明为`private`的属性或方法，子类继承父类以后，仍然认为获取了父类中私有结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已。

子类继承父类以后，还可以声明自己特有的属性和方法：实现功能的拓展。

- 子类和父类的关系，不同于子集和集合的关系。
- `extends`:延展、扩展

### 4.Java 中继承性的说明

- 一个类可以被多个子类继承。
- `Java`中类的单继承性：一个类只能有一个父类
- 子父类是相对的概念
- 子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类
- 子类继承的父类以后，就获取了直接父类以及所间接父类中声明的属性和方法

图示：

![](https://fang-kang.gitee.io/blog-img/java10.png#id=uQcPE&originHeight=331&originWidth=652&originalType=binary&ratio=1&status=done&style=none)

### 5.java.lang.Object 类的理解

- 如果我们没显示的声明一个类的父类的话，则此类继承与`java.lang.Object`类
- 所有的`java`类(除`java.lang.Object`类之外都直接或间接的继承于`java.lang.Object`类)
- 意味着，所有的`java`类具有`java.lang.Object`类声明的功能

## 二.方法的重写

### 1.什么是方法的重写（override 或 overwrite）？

子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作。

### 2.应用

重写以后，当创建子类对象以后，通过子类对象调用字父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。

### 3.举例

```java
class Circle{
    public double findArea(){
        // 求面积
    }
}
class Cylinder extends Circle{
    public double findArea(){
        // 求表面积
    }
}
```

### 4.重写的规则

**方法的声明**：

```java
权限修饰符 返回值类型 方法名（形参列表） thows 异常的类型{
    方法体
}
```

**约定俗称**：子类中的叫重写的方法，父类中的叫被重写的方法。

- 子类重写的方法的方法名和形参列表与父类的被重写的方法的方法名和形参列表相同
- 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符
  **特殊情况**：子类不能重写父类中声明为`private`权限的方法
- 返回值类型
  - 父类被重写的方法的返回值类型是`void`,则子类重写的方法的返回值类型只能是`void`
  - 父类被重写的方法的返回值类型是`A类型`,则子类重写的方法的返回值类型可能是`A类`或`A类的子类`
  - 父类被重写的方法的返回值类型是`基本数据类型（比如:double）`,则子类重写的方法的返回值类型必须是是相同的基本数据类型(必须也是`double`)
- 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型

子类和父类中的同名同参数的方法要么都声明为非`static`的（考虑重写，要么都声明为`static`的（不是重写））

### 5.面试题:区分方法的重载和重写

- 二者的概念
- 重载和重写的具体规则
- 重载：不表现为多态性
  重写：表现为多态性
- 重载，是指允许存在多个同名方法，而这些方法的参数不同，编辑器根据方法不同的参数列表，对同名方法的名称做修饰。对于编辑器而言，这些同名方法构成了不同的方法。它们的调用地址在编译期就绑定了。`Java`的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。
  所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”;
  而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”;
  引用一句`Bruce Eckel`的话：“不要犯傻，如果它不是晚绑定，它就不是多态。";

## 三.关键字：super

### 1.理解

`super`关键字可以理解为父类的

### 2.可以用来调用的结构

属性、方法、构造器

### 3.super 调用属性、方法

- 我们可以在子类的方法或构造器中。通过使用`super`.属性或`super`.方法的方式，显示的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略`super`
- 特殊情况：当子类和父类中定义了同名的属性时，我们想要在子类中调用父类中声明的属性，则必须显示的使用`super`.属性的方式，表明调用的是父类中声明的属性
- 特殊情况：当子类重写了父类中的方法以后，我们想要在子类的方法中调用父类中被重写的方法时，则必须显示的使用`super`.方法的方式，表明调用的是父类中被重写的方法

### 4.super 调用构造器

- 我们可以在子类的构造器中显示的使用`super(形参列表)`的方式，调用父类中声明的指定的构造器
- `super(形参列表)`的使用，必须声明在子类构造器的首行
- 我们在类的构造器中，针对于`this(形参列表)`和`super(形参列表)`只能二选一，不能同时出现
- 在构造器的首行，没显示的声明`this(形参列表)`或`super(形参列表)`，则默认调用的是父类中空参的构造器：`super()`
- 在类的多个构造器中，至少一个类的构造器中使用了`super(形参列表)`，调用父类中的构造器

## 四.子类对象实例化全过程

理解即可。

### 1.从结果上看：继承性

- 子类继承父类以后，就获取了父类中声明的属性或方法。
- 创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。

### 2.从过程上看

当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类构造器，...直到调用了`java.lang.Object`类中空参的构造器为止。
正因为加载过所有的父类的结构，所以才可以看到内存中父类的结构，子类对象才可以考虑进行调用。

### 3.强调说明

虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为`new`的子类对象。

## 五.面向对象的特征三：多态性

### 1.多态性的理解

可以理解为一个事物的多种形态。

### 2.何为多态性

**对象的多态性**：父类的引用指向子类的对象（或子类的对象赋给父类的引用）

**举例**：

```java
Person p = new Man();
Object obj = new Date();
```

### 3.多态性的使用:虚拟方法调用

- 有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。
- 总结：编译，看左边；运行，看右边。

### 4.多态性的使用前提

- 类的继承关系
- 方法的重写

### 5.多态性的应用举例

```java
// 举例一：
public void func(Animal animal){//Animal animal = new Dog();
    animal.eat();
    animal.shout();
}
```

```java
// 举例二：
public void method(Object obj){

}
```

### 6.多态性使用的注意点

对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）

### 7.关于向上转型和向下转型

#### 7.1 向上转型:多态

#### 7.2 向下转型

##### 7.2.1 为什么使用向下转型

有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。

##### 7.2.2 如何实现向下转型

使用强制类型转换符:`()`

##### 7.2.3 使用时的注意点

- 使用强转时，可能出现`ClassCastException`的异常。
- 为了避免在向下转型时出现`ClassCastException`的异常，我们在向下转型之前，先进行`instanceof`的判断，一旦返回`true`，就进行向下转型。如果返回`false`，不进行向下转型。

##### 7.2.4 instanceof 的使用

- `a instanceof A`：判断对象`a`是否是类`A`的实例。如果是，返回`true`;如果不是，返回`false`。
- 如果`a instanceof A`返回`true`,则`a instanceof B`也返回`true`。其中，类`B`是类`A`的父类。
- 要求`a`所属的类与类`A`必须是子类和父类的关系，否则编译错误。

##### 7.2.5 图示

![](https://fang-kang.gitee.io/blog-img/java11.png#id=MTKHa&originHeight=329&originWidth=600&originalType=binary&ratio=1&status=done&style=none)

### 8.面试题

#### 8.1 谈谈你对多态性的理解？

- 实现代码的通用性。
- `Object`类中定义的`public boolean eauals(Object obj){}`
- 抽象类和接口的使用肯定体现了多态性。（抽象类、接口不能实例化）

#### 8.2 多态是编译时行为还是运行时行为？

运行时行为

## 六.Object 类的使用

### 1.java.lang.Object 类的说明

- `Object`类是所有`Java`类的根父类
- 如果在类的声明中未使用`extends`关键字指明其父类，则默认父类为`java.lang.Object`类
- `Object`类中的功能（属性、方法）具有通用性。
  - 属性：无
  - 方法：`equals()` / `toString()` / `getClass()` / `hashCode()` / `clone()` / `finalize()` / `wait()` / `notify()` / `notifyAll()`
- `Object`类只声明了一个空参构造器

### 2.equals()方法

#### 2.1 equals()的使用

- 是一个方法，而非运算符
- 只能适用于引用数据类型
- `Object`类中`equals()`的定义:
  **说明**：`Object`类中定义的`equals()`和`==`的作用是相同的：比较两个对象的地址是否相同，即两个引用是否指向同一个对象实体

```java
public boolean equals(Object obj){
    return (this == obj);
}
```

- 像`String`、`Date`、`File`、包装类等都重写了`Object`类中`equals()`方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象“实体内容”是否相同。
- 通常情况下，我们自定义的类如果使用`equals()`的话，也通常是比较两个对象“实体内容”是否相同。那么，我们就需要对`Object`类中定义的`equals()`进行重写。
  **重写的原则**：比较两个对象“实体内容”是否相同。

#### 2.2 如何重写 equals()

##### 2.2.1 手动重写举例

```java
class User{
    String name;
    int age;
    // 重写equals()
    public boolean equals(Object obj){
        if(obj == this){
            return true;
        }
        if(obj instanceof User){
            User u = (User)obj;
            return this.age == u.age && this.name.equals(u.name);
        }
        return false;
    }
}
```

##### 2.2.2 开发中如何实现:自动生成

#### 2.3 回顾 == 运算符的使用

`==`：运算符

- 可以使用在**基本数据类型变量**和**引用数据类型变量**中
- 如果比较的是**基本数据类型变量**：比较两个变量保存的**数据是否相等**。（不一定类型相同）
  如果比较的是**引用数据类型变量**：比较两个对象的**地址值是否相同**，即两个引用是否指向同一个对象实体

**补充**：`==`符号使用时，必须保证符号左右两边的变量类型一致。

### 3.toString()方法

#### 3.1 toString()的使用

- 当我们输出一个对象的引用时，实际上就是调用当前对象的`toString()`
- `Object`类中`toString()`的定义：

```java
public String toString(){
    return getClass().getName() + "@" + Integer.toHexString(hashCode()));
}
```

- 像`String`、`Date`、`File`、包装类等都重写了`Object`类中`toString()`方法。
  使得在调用对象的`toString()`时，返回“实体内容”信息。
- 自定义类也可以重写`toString()`方法，当调用此方法时，返回对象的“实体内容”。

#### 3.2 如何重写 toString()

举例：

```java
// 自动实现
@Override
public String toString(){
    return "Customer [name=" + name + ", age=" + age + "]";
}
```

### 4.面试题

#### 4.1 final、finally、finalize 的区别

#### 4.2 == 和 equals()的区别

## 七.单元测试方法

### 1.Java 中的 Junit 单元测试

**步骤**：

1. 选中当前工程，右键 build path - add libraries - JUnit4 - 下一步
2. 创建`Java`类，进行单元测试
   此时的`Java`类要求：

- 此类是`public`的
- 此类提供公共的无参构造器

3. 此类中声明单元测试方法
   此时的单元测试方法：方法的权限是`public`,没返回值，没形参
4. 此单元测试方法上需要声明注解：`@Test`,并在单元测试类中导入：`import org.junit.Test;`
5. 声明好单元测试方法以后，就可以在方法体内测试相关的代码。
6. 写完代码以后，左键双击单元测试方法名，右键：`run as`- `JUnit Test`

**说明**：

- 如果执行结果没任何异常：绿条
- 如果执行结果出现异常：红条

## 八.包装类的使用

### 1.为什么要有包装类（或封装类）

为了使基本数据类型的变量具有类的特征，引入包装类。

### 2.基本数据类型与对应的包装类

| 基本数据类型 | 包装类        |
| ------------ | ------------- |
| **char**     | **Character** |
| double       | Double        |
| float        | Float         |
| short        | Short         |
| boolean      | Boolean       |
| byte         | Byte          |
| **int**      | **Integer**   |
| long         | Long          |

### 3.需要掌握的类型间的转换

![](https://fang-kang.gitee.io/blog-img/java12.png#id=bzyri&originHeight=473&originWidth=861&originalType=binary&ratio=1&status=done&style=none)

**简易版**：

- 基本数据类型 `<=>` 包装类：`JDK5.0`新特性：自动装箱与自动拆箱
- 基本数据类型 、包装类 `<=>` `String`：调用`String`重载的`valueOf(Xxx xxx)`
- `String` `<=>` 基本数据类型 、包装类：调用包装类的的`parseXxx(String s)`

**注意**：转换时，可能会报`NumberFormatException`

**应用场景举例**：

`Vector`类中关于添加元素，只定义了形参为`Object`类型的方法：

`v.addElement(Object obj);` // 基本数据类型 `=>` 包装类 `=>` 使用多态
