# 04.面向对象-上

## 一.类与对象

### 1.面向对象学习的三条主线

- `Java`类及类的成员：属性、方法、构造器；代码块、内部类
- 面向对象的三大特征：封装性、继承性、多态性、（抽象性）
- 其他关键字：`this`、`super`、`static`、`final`、`abstract`、`interface`、`package`、`import`等

### 2.面向对象与面向过程(理解)

- 面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。
- 面向对象：强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。

### 3.面向对象中两个重要的概念

**类**：对一类事物的描述，是抽象的、概念上的定义。

**对象**：是实际存在的该类事物的每个个体，因此也称为实例(instance)。

- 面向对象程序设计的重点是类的设计
- 设计类，就是设计类的成员

**二者的关系**：对象，是由类`new`出来的，派生出来的。

### 4.面向对象思想落地实现的规则

1. 创建类，设计类的成员
2. 创建类的对象
3. 通过“对象.属性“或”对象.方法“调用对象的结构

**补充：几个概念的使用说明**

- 属性 = 成员变量 = field = 域、字段
- 方法 = 成员方法 = 函数 = method
- 创建类的对象 = 类的实例化 = 实例化类

### 5.对象的创建与对象的内存解析

**典型代码**：

```java
Person p1 = new Person();
Person p2 = new Person();
Person p3 = p1; //没有新创建一个对象，共用一个堆空间中的对象实体。
```

**说明**：

如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非 static 的）

意味着：如果我们修改一个对象的属性`a`，则不影响另外一个对象属性`a`的值。

**内存解析**：

![](https://fang-kang.gitee.io/blog-img/java07.png#id=vzbbT&originHeight=401&originWidth=706&originalType=binary&ratio=1&status=done&style=none)

### 6.JVM 内存结构

编译完源程序以后，生成一个或多个字节码文件。

我们使用`JVM`中的类的加载器和解释器对生成的字节码文件进行解释运行。意味着，需要将字节码文件对应的类加载到内存中，涉及到内存解析。

![](https://fang-kang.gitee.io/blog-img/java08.png#id=d6fUB&originHeight=373&originWidth=525&originalType=binary&ratio=1&status=done&style=none)

虚拟机栈，即为平时提到的栈结构。我们将局部变量储存在栈结构中

堆,我们将`new`出来的结构（比如：数组、对象）加载到**堆空间**中。补充：对象的属性（非 static 的）加载在堆空间中。

方法区：类的加载信息、常量池、静态域

### 7.匿名对象

**定义**： 我们创建的对象，没显示的赋给一个变量名。即为匿名对象。

**特点**：匿名对象只能调用一次。

**举例**：

```java
new Phone().sendEmail();
new Phone().playGame();

new Phone().price = 1999;
new Phone().showPrice();
```

**应用场景**：

```java
PhoneMall mall = new PhoneMall();
// mall.show(p);
// 匿名对象的使用
mall.show(new Phone());

class PhoneMall{
    public vold show(Phone phone){
        phone.sendEmail();
        phone.playGame();
    }
}
```

## 二.类的结构之一：属性

对比：属性 vs 局部变量

### 1.相同点

- 定义变量的格式：数据类型 变量名 = 变量值
- 先声明，后使用
- 变量都其对应的作用域

### 2.不同点

- 在类中声明的位置的不同
  - 属性：直接定义在类的一对`{}`内
  - 局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量
- 关于权限修饰符的不同
  - 属性：可以在声明属性时，指明其权限，使用权限修饰符。
    常用的权限修饰符：`private`、`public`、缺省、`protected` `=>` 封装性
  - 局部变量：不可以使用权限修饰符
- 默认初始化值的情况
  - 属性：类的属性，根据其类型，都默认初始化值
    整型(`byte`、`short`、`int`、`long` : 0 )
    浮点型(`float` 、 `doubel` : 0.0 )
    字符型(`char` : 0 (或`'\u0000'`))
    布尔型(`boolean` : `false`)
    引用数据类型（类、数组、接口 : `null`）
  - 局部变量：没有默认初始化值
    意味着，我们在调用局部变量之前，一定要显示赋值。
    特别地：形参在调用时，我们赋值即可。
- 在内存中加载的位置
  - 属性：加载到堆空间中（非 static）
  - 局部变量：加载到栈空间

## 三.类的结构之二：方法

### 1.方法的使用

**方法**：描述类应该具有的功能。

**方法的声明**：权限修饰符 返回值类型 方法名（形参列表）{

方法体

}

**注意**：`static`、`final`、`abstract`来修饰方法

**说明**：

- 关于权限修饰符：默认方法的权限修饰符先都使用`public`
  `Java`规定四种权限修饰符:`private`、`public`、缺省、`protected`
- 返回值类型： 返回值 vs 没返回值
  - 如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用`return`关键字来返回指定类型的变量或常量：`return`数据。
  - 如果方法没有返回值，则方法声明时，使用`void`来表示。通常，没返回值的方法中，就不需要使用`return`。但是，如果使用的话，只能`return;`表示此方法结束的意思。
  - 定义方法该不该返回值?
    - 题目要求
    - 凭经验，具体问题具体分析
- 方法名：属于标识符，遵循标识符的规则和规范，“见名知意”。
- 形参列表：可以声明 0 个，1 个或多个形参
  - 格式：数据类型 1 形参 1，数据类型 2 形参 2
  - 定义方法时，该不该定义形参?
    - 题目要求
    - 凭经验，具体问题具体分析
- 方法体：方法功能的体现。
- 方法的使用中，可以调用当前类的属性和方法
  - 特殊的：方法 A 中又调用了方法 A：递归方法。
  - 方法中，不可以定义方法。

### 2.关键字：return

#### 2.1 使用范围

使用在方法体中

#### 2.2 作用

- 结束方法
- 针对于返回值类型的方法，使用`return`数据返回所要的数据。

#### 2.3 注意点

`return`关键字后面不可以声明执行语句。

### 3.方法的重载

#### 3.1 定义

在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。

#### 3.2 总结

**两同一不同**：

- 同一个类、相同方法名
- 参数列表不同：参数个数不同，参数类型不同

#### 3.3 构成重载的举例

举例一：`Arrays`类中重载的 sort()

举例二：

```java
public void getSum(int i, int j){
    System.out.println("1");
}
public void getSum(double d1, double d2){
    System.out.println("2");
}
public void getSum(String s, int i){
    System.out.println("3");
}
public void getSum(int i, String s){
    System.out.println("4");
}
```

#### 3.4 不构成重载的举例

```java
public int getSum(int i, int j){
   return 0;
}
public void getSum(int m, int n){

}
private void getSum(int i, int j){

}
```

#### 3.5 如何判断是否构成方法的重载？

严格按照定义判断：两同一不同。

跟方法的权限修饰符、返回值类型、形参变量名、方法体都没关系。

#### 3.6 如何确定类中某一个方法的调用

方法名 `=>` 参数列表

### 4.可变个数形参的方法

#### 4.1 使用说明

- 可变个数形参的格式：数据类型...变量名
- 当调用可变个数形参的方法时，传入的参数个数可以是：0 个，1 个，2 个。
- 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载
- 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存
- 可变个数形参在方法的形参中，必须声明在末尾
- 可变个数形参在方法的形参中，最多只能声明一个可变形参。

#### 4.2 举例说明

```java
public void show(int i){

}
public void show(String s){
  System.out.println("show String s");
}
public void show(String ... strs){
  System.out.println("String ... strs");
    for(int i = 0;i < strs.length;i++){
        System.out.println(strs[i]);
    }
}
// 不能与上一个方法同时存在
//  public void show(String [] strs){
//
// }
```

### 5.Java 的值传递机制

#### 5.1 针对于方法内变量的赋值举例

**规则**：

- 如果变量是基本数据类型，此时赋值的是变量所保存的数据值。
- 如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。

#### 5.2 针对于方法的参数概念

**形参**：方法定义时，声明的小括号内的参数

**实参**：方法调用时，实际传递给形参的参数

#### 5.3 java 中参数传递机制

**规则**：

- 如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值。
- 如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值。

**推广**：

- 如果变量是基本数据类型，此时赋值的是变量所保存的数据值。
- 如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。

### 6.递归方法

#### 6.1 定义

递归方法：一个方法体内调用它自身。

#### 6.2 如何理解递归方法？

- 方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。
- 递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。

#### 6.3 举例

```java
// 计算1-n之间所有自然数的和
public int getSum(int n){
    if(n == 1){
        return 1;
    }else{
        return n + getSum(n - 1);
    }
}
```

## 四.面向对象的特征一：封装性

### 1.为什么要引入封装性?

- 我们程序设计追求“高内聚，低耦合”。
  - 高内聚：类的内部数据操作细节自己完成，不允许外部干涉；
  - 低耦合：仅对外暴露少量的方法用于使用。
- 隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，把该暴露的暴露出来。这就是封装性的设计思想。

### 2.问题引入

当我们创建一个类的对象以后，我们可以通过“对象.属性”的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没其他制约条件。但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的增加。（比如：`setLegs()`同时，我们需要避免用户再使用“对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的(`private`)）
此时，针对与属性就体现了封装性。

### 3.封装性思想具体的代码体现

#### 3.1 体现一

将类的属性 xxx 私有化(`private`),同时，提供公共的(`public`)方法来获取(`getXxx`)和设置(`setXxx`)此属性的值。

```java
private double redius;
public void setRedius(double redius){
    this.redius = redius;
}
public double getRedius(double redius){
    return this.redius;
}
```

#### 3.2 体现二

不对外暴露私有的方法

#### 3.3 体现三

单例模式（将构造器私有化）

#### 3.4 体现四

如果不希望类在包外被调用，可以将类设置为缺省的。

### 4.Java 规定的四种权限修饰符

#### 4.1 权限从小到大顺序为

`private` => 缺省 => `protected` => `public`

#### 4.2 具体的修饰范围

| 修饰符    | 类内部 | 同一个包 | 不同包的子类 | 同一个工程 |
| --------- | ------ | -------- | ------------ | ---------- |
| private   | Yes    |          |              |            |
| 缺省      | Yes    | Yes      |              |            |
| protected | Yes    | Yes      | Yes          |            |
| public    | Yes    | Yes      | Yes          | Yes        |

#### 4.3 权限修饰符可用来修饰的结构说明

4 种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类。

修饰类的话，只能使用：缺省、`public`

## 五.类的结构：构造器

### 1.构造器（或构造方法）：Constructor

**构造器的作用**：

1. 创建对象
2. 初始化对象的信息

### 2.使用说明

1. 如果没显示的定义类的构造器的话，则系统默认提供一个空参的构造器。
2. 定义构造器的格式：权限修饰符 类名（形参列表）{}
3. 一个类中定义的多个构造器，彼此构成重载
4. 一旦我们显示的定义了类的构造器之后，系统就不在提供默认的空参构造器
5. 一个类中，至少会有一个构造器

### 3.举例

```java
// 构造器
public void Person(){
    System.out.println("Person()");
}
public void Person(String n){
    name = n;
}
public void Person(String n,int a){
    name = n;
    age = a;
}
```

### 4.总结：属性赋值的先后顺序

1. 默认初始化
2. 显示初始化
3. 构造器中初始化
4. 通过“对象.方法”或“对象.属性”的方式赋值

**以上操作的先后顺序：1-2-3-4**

### 5.JavaBean

所谓`JavaBean`，是指符合如下标准的`Java`类

- 类是公共的
- 一个无参的公共的构造器
- 属性，而且对应的`get`、`set`方法

## 六.关键字：this

### 1.可以调用的结构

属性、方法、构造器

### 2.this 调用属性、方法

`this`理解为：当前对象 或 当前正在创建的对象

- 在类的方法中，我们可以使用`this`.属性或`this`.方法的方式，调用当前对象属性或方法。但是，通常情况下，我们都省略`this`。特殊情况下，如果方法的形参和类的属性同名时，我们必须显示的使用`this`.变量的方式，表明此变量是属性，而非形参。
- 在类的构造器中，我们可以使用`this`.属性或`this`.方法的方式，调用当前正在创建的对象属性或方法。但是，通常情况下，我们都省略`this`。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显示的使用`this`.变量的方式，表明此变量是属性，而非形参。

### 3.this 调用构造器

1. 我们在类的构造器中，可以显示的使用`this（形参列表）`的方式，调用本类中指定的其他构造器。
2. 构造器中不能通过`this（形参列表）`的方式调用自己。
3. 如果一个类中有`n`个构造器，则最多有`n-1`构造器中使用了`this（形参列表）`。
4. 规定：`this（形参列表）`必须声明在当前构造器首行。
5. 构造器内部，最多只能声明一个`this（形参列表）`，用来调用其他构造器。

## 七.关键字：package/import

### 1.package 的使用

#### 1.1 使用说明

- 为了更好的实现项目中类的管理，提供包的概念
- 使用`package`声明类或接口所属的包，声明在源文件的首行
- 包，属于标识符，遵循标识符的命名规则，规范（xxxyyyzzz）、“见名知意”
- 每`.`一次，就代表一层文件目录

#### 1.2JDK 的主要包介绍

![](https://fang-kang.gitee.io/blog-img/java09.png#id=Em2qd&originHeight=305&originWidth=665&originalType=binary&ratio=1&status=done&style=none)

### 2.import 的使用

`import`：导入

- 在源文件中显示的使用`import`结构导入指定包下的类、接口
- 声明在包的声明和类的声明之间
- 如果需要导入多个结构，则并列写出即可
- 可以使用`xxx.*`的方式，表示可以导入`xxx`包下的所有结构
- 如果使用的类或接口是`java.lang`包下定义的，则可以省略`import`结构
- 如果使用的类或接口是本包下定义的，则可以省略`import`结构
- 如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式显示
- 使用`xxx.*`的方式表面可以调用`xxx`包下的所有结构。但是如果使用的是`xxx`子包下的结构，则仍需要显示导入
- `import static`:导入指定类或接口中的静态结构：属性或方法
 
 
 <git-talk/>