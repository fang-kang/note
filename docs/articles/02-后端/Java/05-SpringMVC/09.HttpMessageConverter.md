# 09.HttpMessageConverter

HttpMessageConverter，报文信息转换器，将请求报文转换为 Java 对象，或将 Java 对象转换为响应报文

HttpMessageConverter 提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity，

ResponseEntity

## 1、@RequestBody

/RequestBody 可以获取请求体，需要在控制器方法设置一个形参，使用/RequestBody 进行标识，当前请求的请求体就会为当前注解所标识的形参赋值

```html
<form th:action="@{/testRequestBody}" method="post">
  用户名：<input type="text" name="username" />

  密码：<input type="password" name="password" />

  <input type="submit" />
</form>
```

```java
@RequestMapping("/testRequestBody")
public String testRequestBody(@RequestBody String requestBody){
    System.out.println("requestBody:"+requestBody);
    return "success";
}
```

输出结果：

`requestBody:username=admin&password=123456`

## 2、RequestEntity

RequestEntity 封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过 getHeaders()获取请求头信息，通过 getBody()获取请求体信息

```java
@RequestMapping("/testRequestEntity")
public String testRequestEntity(RequestEntity<String> requestEntity){
    System.out.println("requestHeader:"+requestEntity.getHeaders());
    System.out.println("requestBody:"+requestEntity.getBody());
    return "success";
}
```

输出结果：

```bash
requestHeader:[host:"localhost:8080", connection:"keep-alive", content-length:"27", cache-control:"max-age=0", sec-ch-ua:"" Not A;Brand";v="99", "Chromium";v="90", "Google Chrome";v="90"", sec-ch-ua-mobile:"?0", upgrade-insecure-requests:"1", origin:"[http://localhost:8080](http://localhost:8080)", user-agent:"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36"]
requestBody:username=admin&password=123
```

## 3、RequestBody

RequestBody 用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器

```java
@RequestMapping("/testResponseBody")
@ResponseBody
public String testResponseBody(){
    return "success";
}
```

结果：浏览器页面显示 success

## 4、SpringMVC 处理 json

RequestBody 处理 json 的步骤：

a>导入 jackson 的依赖

```xml
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.12.1</version>
</dependency>
```

b>在 SpringMVC 的核心配置文件中开启 mvc 的注解驱动，此时在 HandlerAdaptor 中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的 Java 对象转换为 Json 格式的字符串

```xml
<mvc:annotation-driven />
```

c>在处理器方法上使用 RequestBody 注解进行标识

d>将 Java 对象直接作为控制器方法的返回值返回，就会自动转换为 Json 格式的字符串

```java
@RequestMapping("/testResponseUser")
@ResponseBody
public User testResponseUser(){
    return new User(1001,"admin","123456",23,"男");
}
```

浏览器的页面中展示的结果：

`{"id":1001,"username":"admin","password":"123456","age":23,"sex":"男"}`

## 5、SpringMVC 处理 ajax

a>请求超链接：

```html
<div id="app">
  <a th:href="@{/testAjax}" @click="testAjax">testAjax</a>
</div>
```

b>通过 vue 和 axios 处理点击事件：

```html
<script type="text/javascript" th:src="@{/static/js/vue.js}"></script>
<script type="text/javascript" th:src="@{/static/js/axios.min.js}"></script>
<script type="text/javascript">
  var vue = new Vue({
    el: '#app',
    methods: {
      testAjax: function (event) {
        axios({
          method: 'post',
          url: event.target.href,
          params: {
            username: 'admin',
            password: '123456',
          },
        }).then(function (response) {
          alert(response.data)
        })
        event.preventDefault()
      },
    },
  })
</script>
```

c>控制器方法：

```java
@RequestMapping("/testAjax")
@ResponseBody
public String testAjax(String username, String password){
    System.out.println("username:"+username+",password:"+password);
    return "hello,ajax";
}
```

## 6、RestController 注解

RestController 注解是 springMVC 提供的一个复合注解，标识在控制器的类上，就相当于为类添加了 Controller 注解，并且为其中的每个方法添加了 ResponseBody 注解

## 7、ResponseEntity

ResponseEntity 用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文
