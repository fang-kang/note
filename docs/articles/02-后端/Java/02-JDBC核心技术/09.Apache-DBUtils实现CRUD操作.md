# 09.Apache-DBUtils 实现 CRUD 操作

## 9.1 Apache-DBUtils 简介

- commons-dbutils 是 Apache 组织提供的一个开源 JDBC 工具类库，它是对 JDBC 的简单封装，学习成本极低，并且使用 dbutils 能极大简化 jdbc 编码的工作量，同时也不会影响程序的性能。
- API 介绍：
  - org.apache.commons.dbutils.QueryRunner
  - org.apache.commons.dbutils.ResultSetHandler
  - 工具类：org.apache.commons.dbutils.DbUtils
- API 包说明：

![](https://fang-kang.gitee.io/blog-img/jdbc/1555595163263.png#id=IIvmf&originHeight=313&originWidth=846&originalType=binary&ratio=1&status=done&style=none)

![](https://fang-kang.gitee.io/blog-img/jdbc/1555595198644.png#id=Nc1HV&originHeight=554&originWidth=768&originalType=binary&ratio=1&status=done&style=none)

## 9.2 主要 API 的使用

### 9.2.1 DbUtils

- DbUtils ：提供如关闭连接、装载 JDBC 驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：
  - **public static void close(…) throws java.sql.SQLException**：　 DbUtils 类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是 NULL，如果不是的话，它们就关闭 Connection、Statement 和 ResultSet。
  - public static void closeQuietly(…): 这一类方法不仅能在 Connection、Statement 和 ResultSet 为 NULL 情况下避免关闭，还能隐藏一些在程序中抛出的 SQLEeception。
  - public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接
  - public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出 SQL 异常。
  - public static void rollback(Connection conn)throws SQLException：允许 conn 为 null，因为方法内部做了判断
  - public static void rollbackAndClose(Connection conn)throws SQLException
  - rollbackAndCloseQuietly(Connection)
  - public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册 JDBC 驱动程序，如果成功就返回 true。使用该方法，你不需要捕捉这个异常 ClassNotFoundException。

### 9.2.2 QueryRunner 类

- **该类简单化了 SQL 查询，它与 ResultSetHandler 组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。**
- QueryRunner 类提供了两个构造器：
  - 默认的构造器
  - 需要一个 javax.sql.DataSource 来作参数的构造器
- QueryRunner 类的主要方法：
  - **更新**

```java
public int update(Connection conn, String sql, Object... params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。
```

- **插入**

```java
 public <T> T insert(Connection conn,String sql,ResultSetHandler<T> rsh, Object... params) throws SQLException：只支持 INSERT 语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys. 返回值: An object generated by the handler.即自动生成的键值
```

- **批处理**

```java
  - public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE 语句
  - public <T> T insertBatch(Connection conn,String sql,ResultSetHandler<T> rsh,Object[][] params)throws SQLException：只支持 INSERT 语句
```

- **查询**

```java
  - public Object query(Connection conn, String sql, ResultSetHandler rsh,Object... params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。
```

- 测试

```java
// 测试添加
@Test
public void testInsert() throws Exception {
 QueryRunner runner = new QueryRunner();
 Connection conn = JDBCUtils.getConnection3();
 String sql = "insert into customers(name,email,birth)values(?,?,?)";
 int count = runner.update(conn, sql, "何成飞", "he@qq.com", "1992-09-08");

 System.out.println("添加了" + count + "条记录");

 JDBCUtils.closeResource(conn, null);

}
```

```java
// 测试删除
@Test
public void testDelete() throws Exception {
 QueryRunner runner = new QueryRunner();
 Connection conn = JDBCUtils.getConnection3();
 String sql = "delete from customers where id < ?";
 int count = runner.update(conn, sql,3);

 System.out.println("删除了" + count + "条记录");

 JDBCUtils.closeResource(conn, null);

}
```

### 9.2.3 ResultSetHandler 接口及实现类

- 该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。
- ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。
- 接口的主要实现类：

  - ArrayHandler：把结果集中的第一行数据转成对象数组。
  - ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到 List 中。
  - **BeanHandler：**将结果集中的第一行数据封装到一个对应的 JavaBean 实例中。
  - **BeanListHandler：**将结果集中的每一行数据都封装到一个对应的 JavaBean 实例中，存放到 List 里。
  - ColumnListHandler：将结果集中某一列的数据存放到 List 中。
  - KeyedHandler(name)：将结果集中的每一行数据都封装到一个 Map 里，再把这些 map 再存到一个 map 里，其 key 为指定的 key。
  - **MapHandler：**将结果集中的第一行数据封装到一个 Map 里，key 是列名，value 就是对应的值。
  - **MapListHandler：**将结果集中的每一行数据都封装到一个 Map 里，然后再存放到 List
  - **ScalarHandler：**查询单个值对象

- 测试

```java
/*
 * 测试查询:查询一条记录
 *
 * 使用ResultSetHandler的实现类：BeanHandler
 */
@Test
public void testQueryInstance() throws Exception{
 QueryRunner runner = new QueryRunner();

 Connection conn = JDBCUtils.getConnection3();

 String sql = "select id,name,email,birth from customers where id = ?";

 //
 BeanHandler<Customer> handler = new BeanHandler<>(Customer.class);
 Customer customer = runner.query(conn, sql, handler, 23);
 System.out.println(customer);
 JDBCUtils.closeResource(conn, null);
}
```

```java
/*
 * 测试查询:查询多条记录构成的集合
 *
 * 使用ResultSetHandler的实现类：BeanListHandler
 */
@Test
public void testQueryList() throws Exception{
 QueryRunner runner = new QueryRunner();

 Connection conn = JDBCUtils.getConnection3();

 String sql = "select id,name,email,birth from customers where id < ?";

 //
 BeanListHandler<Customer> handler = new BeanListHandler<>(Customer.class);
 List<Customer> list = runner.query(conn, sql, handler, 23);
 list.forEach(System.out::println);

 JDBCUtils.closeResource(conn, null);
}
```

```java
/*
 * 自定义ResultSetHandler的实现类
 */
@Test
public void testQueryInstance1() throws Exception{
 QueryRunner runner = new QueryRunner();

 Connection conn = JDBCUtils.getConnection3();

 String sql = "select id,name,email,birth from customers where id = ?";

 ResultSetHandler<Customer> handler = new ResultSetHandler<Customer>() {

  @Override
  public Customer handle(ResultSet rs) throws SQLException {
   System.out.println("handle");
//   return new Customer(1,"Tom","tom@126.com",new Date(123323432L));

   if(rs.next()){
    int id = rs.getInt("id");
    String name = rs.getString("name");
    String email = rs.getString("email");
    Date birth = rs.getDate("birth");

    return new Customer(id, name, email, birth);
   }
   return null;

  }
 };

 Customer customer = runner.query(conn, sql, handler, 23);

 System.out.println(customer);

 JDBCUtils.closeResource(conn, null);
}
```

```java
/*
 * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据，
 * 使用ScalarHandler
 *
 */
@Test
public void testQueryValue() throws Exception{
 QueryRunner runner = new QueryRunner();

 Connection conn = JDBCUtils.getConnection3();

 //测试一：
// String sql = "select count(*) from customers where id < ?";
// ScalarHandler handler = new ScalarHandler();
// long count = (long) runner.query(conn, sql, handler, 20);
// System.out.println(count);

 //测试二：
 String sql = "select max(birth) from customers";
 ScalarHandler handler = new ScalarHandler();
 Date birth = (Date) runner.query(conn, sql, handler);
 System.out.println(birth);

 JDBCUtils.closeResource(conn, null);
}
```

## JDBC 总结

```java
总结
@Test
public void testUpdateWithTx() {

 Connection conn = null;
 try {
  //1.获取连接的操作（
  //① 手写的连接：JDBCUtils.getConnection();
  //② 使用数据库连接池：C3P0;DBCP;Druid
  //2.对数据表进行一系列CRUD操作
  //① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \ version 2.0)
//version2.0的增删改public void update(Connection conn,String sql,Object ... args){}
//version2.0的查询 public <T> T getInstance(Connection conn,Class<T> clazz,String sql,Object ... args){}
  //② 使用dbutils提供的jar包中提供的QueryRunner类

  //提交数据
  conn.commit();


 } catch (Exception e) {
  e.printStackTrace();


  try {
   //回滚数据
   conn.rollback();
  } catch (SQLException e1) {
   e1.printStackTrace();
  }

 }finally{
  //3.关闭连接等操作
  //① JDBCUtils.closeResource();
  //② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作

 }
}
```
 
 