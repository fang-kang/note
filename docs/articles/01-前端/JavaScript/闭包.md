# 闭包

## 1. 什么是闭包?

- 首先看看维基百科对闭包的定义

1. `闭包`（Closure），又称`词法闭包`（Lexical Closure）或`函数闭包`（function closures），是在支持头等函数的编程语言中实现词法绑定的一种技术。
2. 闭包在实现上是一个结构体，它存储了一个函数（通常是其入口地址）和一个关联的环境（相当于一个符号查找表）。
3. 闭包跟函数最大的不同在于，当捕捉闭包的时候，它的自由变量会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行。

- 再来看一下 MDN 对 JavaScript 闭包的解释

1. `闭包`（closure）是一个函数以及其捆绑的周边环境状态（`lexical environment`，`词法环境`）的引用的组合
2. 闭包能让开发者可以从内部函数访问外部函数的作用域。
3. 在 JavaScript 中，闭包会随着函数的创建而被同时创建。

- **总的来说,闭包就是能够读取其他函数内部变量的函数**。

## 2. 闭包的产生

JavaScript 三大特性,而闭包产生的原因也正是因为这些特性:

1. 可以在 JavaScript 函数内部定义新的函数;
2. 内部函数中访问函数中的定义;
3. 在 JavaScript 中,函数是一等公民,所以函数中既可以传入一个函数又可以作为参数返回一个函数。

```js
function foo() {
  var num = 1
  var test = 2

  function bar() {
    const may = num + 3
    return may
  }

  console.log(test)

  return bar
}

var baz = foo()

baz() // 嗨,朋友,这就是闭包
```

- 通过观察上面的代码,我们在 foo 函数中定义了 bar 函数,并返回 bar 函数,同时在 bar 函数中访问了 foo 函数中的变量 num。
- 上面的代码大概的执行流程为:

1. 当调用 `foo` 函数时，`foo` 函数会将它的内部函数 `bar` 返回给全局变量 `baz`；
2. 等到 `foo` 函数执行结束时，执行上下文会被 `V8` 销毁；

- 按照正常的情况来说,变量 `num` 已经被 V8 销毁了,因为我们知道 V8 引擎有垃圾回收期用来释放不再使用的内存空间,但是由于存活的函数 `bar` 依然引用了 `foo` 函数作用域中的变量 `num`,这样就会带来两个问题:

1. 当 `foo` 执行结束时，变量 `num` 该不该被销毁？如果不应该被销毁,那么他应该在什么时候销毁，而又应该采用什么策略？
2. 我们都知道 V8 引擎采用的是惰性解析的方案,那么当执行到 `foo` 函数时, V8 只会解析 `foo` 函数,并不会解析内部的 `bar`函数,仅仅知识对 `bar`函数进行了标记,在这时 V8 引擎并不知道 `bar` 函数中是否引用了 外层函数作用域中的变量 `num`;

- 由于 `JavaScript` 是一门基于堆和栈的语言。在执行全局代码时当执行，`V8` 会将全局执行上下文压入到调用栈中，然后进入执行 `foo` 函数的调用过程。
- 这时候 `V8` 引擎会为 `foo` 函数创建执行上下文，执行上下文中包括了变量 `num`，然后将 `foo` 函数的执行上下文压入栈中，foo 函数执行结束之后，foo 函数执行上下文从栈中弹出，这时候 `foo` 执行上下文中的变量 `num` 也随之被销毁。
- 正常的处理方式应该是 `foo` 函数的执行上下文被销毁了,但是 `bar` 函数引用的 `foo` 函数中的变量却不能被销毁。
- 在执行 `foo` 函数的阶段,虽然采取了惰性解析,不会解析和执行 `foo` 函数中的的 `bar` 函数中的 `bar` 函数,但是 `V8`还是需要判断 `bar` 函数是否引用了 `foo` 函数中的变量。
- `V8` 引擎引入了预解析器,当解析顶层代码的时候,遇到了一个函数,那么预解析器并不会直接跳过该函数,而是对该书做一次快速的预解析,其中主要的目的主要有两个:

1. 判断当前函数是否是不是存在一些语法上的错误,如果发现语法错误,那么就会向 V8 抛出语法错误;
2. 判断 `foo` 函数是否有被 `bar` 函数引用的变量,如果有,就会把该变量复制一份到堆内存中,同时 `bar` 函数本身也是一个对象,也会被存放到内存当中,这样即使 `foo` 函数即使执行完成,内存被释放以后,`bar` 函数在执行的时候,依然可以从堆内存中访问复制过来的变量;

## 3. Other Example

```js
function foo() {
  var num = 1

  function baz() {
    console.log(num)
  }

  bar(baz)
}

function bar(fn) {
  fn() // 这也是一个闭包
}

foo()
```

- 把内部函数 `baz` 传递给 `bar` 函数,当调用这个内部函数时(这个时候叫作 `fn`),它涵盖的 `foo`()内部作用域的闭包就可以观察到了,因为他能够访问。

```js
function wait(messnum) {
  setTimeout(function timer() {
    console.log(messnum)
  }, 1000)
}

wait('hello world')

function wait(messnum) {
  setTimeout(function timer() {
    console.log(messnum)
  }, 1000)
}

wait('hello world') // 这也是一个闭包
```

- 将一个内部函数 `timer` 传递给`settimeout`(...)。timer 函数依然保存有`wait`(...)作用域的闭包。

- 在引擎内部,内置的工具函数`settimeout`(...)持有对一个参数的引用,这个参数也许叫作 fn 或者 func,又或者其他类型的名字。引擎会调用这个函数,在这个例子中就是内部的 timer 函数,而词法作用域在这个过程中保持完整。

## 4. 经典永不过时

```js
for (var i = 0; i <= 5; i++) {
  setTimeout(() => {
    console.log(i)
  }, i * 10000)
}
```

- 正常情况下,我们对这段代码行为的预期分别是输出 1~5,每秒一次,每次一个。但实际上,这段代码在运行时会以每秒一次输出的频率输出五次 6。因为这个循环的终止条件是 `i` 不再`<=5`,条件时 `i` 的值为 6,因此输出显示的是循环结束时 `i` 的最终值。

- 这是因为 `setTimeout` 是异步的，而 for 循环是同步的，延迟函数的回调会在循环结束时才执行，当循环结束时 `i` 已经是 6 了，所有的回调函数才会开始执行，因此会每次输出一个 `6` 来。

- 那么有什么办法可以让这个循环一次输出数字呢? 用 `let` 关键字代替 `var`? 答案当然是可以的 , 你会看到 `0 1 2 3 4 5` 成功输出。

```js
for (let i = 0; i <= 5; i++) {
  setTimeout(() => {
    console.log(i) // 0 1 2 3 4 5 成功输出
  }, 1000)
}
```

- 如果不用 `let`,用立即执行函数(`IIFE`)呢?

```js
for (var i = 0; i <= 5; i++) {
  ;(function () {
    setTimeout(() => {
      console.log(i) // 输出 6 次 6
    }, 1000)
  })()
}
```

- 这样明显是不行的,为什么呢?虽然我们拥有了跟多的词法作用域了,每个延迟函数都会将 `IIFE` 在每次迭代中创建的作用域封闭起来。但是该错用域是空的,所以 `IIFE`只是一个什么都没有的空作用域。

```js
for (var i = 0; i <= 5; i++) {
  ;(function (j) {
    setTimeout(() => {
      console.log(j) // 0 1 2 3 4 5 成功输出
    }, 1000)
  })(i)
}
```

- 在这里我们把 `i` 作为参数传递给 `立即执行函数` ,`j` 就是传进来的参数,这个时候 `立即执行函数` 就有自己的作用域变量 `j` 了,问题就迎刃而解了。这就是闭包的力量。

## 5. 用闭包模拟私有方法

```js
function Counter() {
  var num = 0

  this.getNum = function () {
    return num
  }

  this.add = function () {
    num++
  }
}

const counter = new Counter()

counter.add()
counter.add()
console.log(counter.getNum())
```

- 在上面的代码中,我们创建了一个构造函数 `Counter` ,定义了一个变量 `num` 用于保存状态。由于 JavaScript 的作用域规则的限制,因此只能在构造函数内部访问该变量。

- 我们可以通过方法读写私有变量,但是不能直接对 `num` 变量直接进行读写,这就实现了私有变量了。

## 6. 闭包的优缺点

- 优点

1. 可以将一个变量长期储存在内存中，用于缓存;
2. 可以避免全局变量的污染;
3. 加强封装性，变量的私有化;

- 缺点

1. 因为函数外部引用的变量不会被销毁，所以会导致内存消耗很大，增加了内存消耗量，影响网页性能出现问题;
2. 而且过度的使用闭包可能会导致内存泄漏，或程序加载运行过慢卡顿等问题的出现。所以我们可以在退出函数之前将不使用的局部变量进行删除;

:::warning 注意

虽然闭包带给我们一定的好处,但是处理不好,很可能给我们带来严重的灾害。如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。。所以在开发中应尽量避免使用闭包。正所谓代码千万条，规范第一条，代码不规范，开发两行泪。

:::
